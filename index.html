<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Type Animation</title>
    <style>
        /* Focused reading popup for personal history */
        #personal-popup-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.32);
            z-index: 6000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        #personal-popup {
            background: #fff;
            color: #222;
            max-width: 520px;
            min-width: 260px;
            padding: 36px 32px 28px 32px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.18);
            font-size: 1.18rem;
            font-family: Arial, sans-serif;
            line-height: 1.7;
            text-align: left;
            position: relative;
            white-space: pre-wrap;
        }
        #personal-popup-close {
            position: absolute;
            top: 12px;
            right: 18px;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #888;
            cursor: pointer;
            transition: color 0.2s;
        }
        #personal-popup-close:hover {
            color: #1976d2;
        }
        /* Minimal glowing Courier reminder */
        #courier-reminder {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Courier New', Courier, monospace;
            font-size: 2.1rem;
            color: #888;
            background: none;
            padding: 0;
            border-radius: 0;
            box-shadow: none;
            text-shadow: 0 0 18px #1976d2, 0 0 8px #fff, 0 0 2px #1976d2, 0 0 16px #888;
            z-index: 5000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s cubic-bezier(.4,2,.6,1);
        }
        #courier-reminder.show {
            opacity: 1;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #ffffff;
            overflow: hidden;
            font-family: Arial, sans-serif;
            position: relative;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .char {
            position: absolute;
            font-size: 80px;
            color: #000;
            font-weight: bold;
            pointer-events: none;
            animation: fadeFloat 1.2s ease-out forwards;
        }
        
        @keyframes fadeFloat {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.5);
            }
        }
        
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(240, 240, 240, 0.95);
            padding: 0;
            border-radius: 12px;
            color: #333;
            z-index: 1000;
            min-width: 280px;
            max-width: 280px;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        #background-toggle {
            position: fixed;
            top: 20px;
            right: 310px;
            width: 50px;
            height: 50px;
            background: rgba(200, 200, 200, 0.95);
            border: none;
            border-radius: 12px;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        #background-toggle:hover {
            background: rgba(180, 180, 180, 0.95);
            transform: scale(1.05);
        }
        
        #background-toggle.rotating {
            animation: rotateIcon 0.5s ease;
        }
        
        /* Push background toggle when controls expand */
        #controls.collapsed ~ #background-toggle {
            right: 80px;
        }
        
        #volume-control {
            position: fixed;
            top: 20px;
            right: 430px;
            width: 50px;
            height: 50px;
            background: rgba(200, 200, 200, 0.95);
            border: none;
            border-radius: 12px;
            color: #333;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-size: 0;
        }
        
        #volume-control:hover {
            background: rgba(180, 180, 180, 0.95);
        }
        
        #controls.collapsed ~ #volume-control {
            right: 200px;
        }

        /* Fish toggle - match style of other top-right controls */
        #fish-toggle {
            position: fixed;
            top: 20px;
            right: 370px;
            width: 50px;
            height: 50px;
            background: rgba(200, 200, 200, 0.95);
            border: none;
            border-radius: 12px;
            color: #333;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-size: 0; /* icon only */
        }

        #fish-toggle:hover {
            background: rgba(180, 180, 180, 0.95);
            transform: scale(1.05);
        }

        #controls.collapsed ~ #fish-toggle {
            right: 140px;
        }

        /* Active state for fish toggle */
        #fish-toggle.active {
            background: rgba(120, 200, 180, 0.95);
            color: #fff;
            transform: translateY(-1px) scale(1.03);
        }

        /* Audio control */
        #audio-control {
            position: fixed;
            top: 20px;
            right: 490px;
            width: 50px;
            height: 50px;
            background: rgba(200, 200, 200, 0.95);
            border: none;
            border-radius: 12px;
            color: #333;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-size: 20px;
        }

        #audio-control:hover { background: rgba(180,180,180,0.95); transform: scale(1.05); }
        #controls.collapsed ~ #audio-control { right: 260px; }
        #audio-control.active { background: rgba(120,160,240,0.95); color: #fff; transform: translateY(-1px) scale(1.03); }
        
        #volume-slider-container {
            position: fixed;
            top: 80px;
            right: 370px;
            width: 50px;
            height: 150px;
            background: rgba(240, 240, 240, 0.95);
            border-radius: 12px;
            padding: 15px 10px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: none;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        #volume-slider-container.show {
            display: flex;
        }
        
        #controls.collapsed ~ #volume-slider-container {
            right: 140px;
        }
        
        #volume-slider-vertical {
            writing-mode: bt-lr;
            appearance: slider-vertical;
            -webkit-appearance: slider-vertical;
            width: 8px;
            height: 100%;
            padding: 0;
            margin: 0;
            accent-color: #888;
            cursor: pointer;
        }
        
        #volume-value {
            font-size: 11px;
            color: #666;
            margin-top: 8px;
            font-weight: 500;
        }
        
        /* SVG icon styles */
        .icon-svg {
            width: 24px;
            height: 24px;
            fill: #333;
        }
        
        @keyframes rotateIcon {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        
        .svg-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            opacity: 0;
            transition: opacity 0.8s ease;
        }
        
        .svg-background.active {
            opacity: 1;
        }
        
        .svg-background svg {
            width: 100%;
            height: 100%;
        }
        
        /* Forest Animation - Organic, chaotic growth */
        @keyframes floatForest1 {
            0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
            25% { transform: translate(40px, -30px) scale(1.15) rotate(5deg); }
            50% { transform: translate(-15px, 25px) scale(0.92) rotate(-3deg); }
            75% { transform: translate(25px, 15px) scale(1.08) rotate(8deg); }
        }
        
        @keyframes floatForest2 {
            0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
            30% { transform: translate(-35px, 40px) scale(1.12) rotate(-7deg); }
            60% { transform: translate(30px, -20px) scale(0.88) rotate(4deg); }
            85% { transform: translate(-10px, 30px) scale(1.05) rotate(-2deg); }
        }
        
        @keyframes floatForest3 {
            0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
            20% { transform: translate(20px, 35px) scale(0.93) rotate(6deg); }
            55% { transform: translate(-40px, -15px) scale(1.1) rotate(-5deg); }
            80% { transform: translate(15px, -25px) scale(1.03) rotate(3deg); }
        }
        
        /* Ocean Animation - Fluid, wave-like motion */
        @keyframes waveOcean1 {
            0%, 100% { transform: translateY(0) scaleX(1) scaleY(1); }
            33% { transform: translateY(-35px) scaleX(1.12) scaleY(0.95); }
            66% { transform: translateY(25px) scaleX(0.92) scaleY(1.08); }
        }
        
        @keyframes waveOcean2 {
            0%, 100% { transform: translateY(0) scaleX(1) scaleY(1) rotate(0deg); }
            25% { transform: translateY(40px) scaleX(0.88) scaleY(1.1) rotate(-3deg); }
            50% { transform: translateY(-20px) scaleX(1.15) scaleY(0.92) rotate(2deg); }
            75% { transform: translateY(15px) scaleX(0.95) scaleY(1.05) rotate(-1deg); }
        }
        
        @keyframes waveOcean3 {
            0%, 100% { transform: translate(0, 0) scale(1); }
            40% { transform: translate(-25px, -30px) scale(1.08); }
            80% { transform: translate(20px, 35px) scale(0.94); }
        }
        
        /* Mountain Animation - Crystalline, geometric drift */
        @keyframes driftMountain1 {
            0%, 100% { transform: translate(0, 0) rotate(0deg) skewX(0deg); }
            35% { transform: translate(25px, -20px) rotate(3deg) skewX(2deg); }
            70% { transform: translate(-18px, 28px) rotate(-2deg) skewX(-3deg); }
        }
        
        @keyframes driftMountain2 {
            0%, 100% { transform: translate(0, 0) rotate(0deg) scale(1); }
            25% { transform: translate(-30px, 25px) rotate(-4deg) scale(1.06); }
            50% { transform: translate(20px, -15px) rotate(2deg) scale(0.96); }
            75% { transform: translate(15px, 30px) rotate(-1deg) scale(1.02); }
        }
        
        @keyframes driftMountain3 {
            0%, 100% { transform: translate(0, 0) rotate(0deg) skewY(0deg); }
            30% { transform: translate(35px, 18px) rotate(2deg) skewY(3deg); }
            65% { transform: translate(-22px, -25px) rotate(-3deg) skewY(-2deg); }
        }
        
        #controls.collapsed {
            width: 50px;
            min-width: 50px;
        }
        
        #toggle-btn {
            width: 100%;
            padding: 15px;
            background: rgba(200, 200, 200, 0.9);
            border: none;
            color: #333;
            font-size: 20px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        
        #toggle-btn:hover {
            background: rgba(180, 180, 180, 0.9);
        }
        
        #controls-content {
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }
        
        #controls.collapsed #controls-content {
            max-height: 0;
            padding: 0 20px;
            opacity: 0;
        }
        
        #controls h3 {
            margin-bottom: 15px;
            font-size: 18px;
            color: #333;
            font-weight: 600;
        }
        
        #font-select {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 15px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            color: #333;
            font-size: 14px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        #font-select:hover {
            border-color: #bbb;
            background: #fafafa;
        }
        
        #font-select option {
            background: #fff;
            color: #333;
            padding: 8px;
        }
        
        .divider {
            border-top: 1px solid #ddd;
            margin: 15px 0;
        }
        
        .section-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            margin-top: 5px;
            font-weight: 500;
        }
        
        #color-picker, #size-slider {
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
        }
        
        #color-picker {
            height: 40px;
        }
        
        #size-slider {
            accent-color: #888;
        }
        
        .slider-value {
            display: inline-block;
            background: #333;
            color: #fff;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            margin-left: 8px;
        }
        
        #font-upload {
            display: block;
            margin-bottom: 10px;
            padding: 10px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            color: #333;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            transition: all 0.2s;
        }
        
        #font-upload:hover {
            background: #fafafa;
            border-color: #bbb;
        }
        
        #font-upload::-webkit-file-upload-button {
            background: #333;
            border: none;
            padding: 6px 14px;
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        #font-upload::-webkit-file-upload-button:hover {
            background: #555;
        }
        
        .info {
            font-size: 12px;
            color: #888;
            margin-top: 10px;
        }
        
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(240, 240, 240, 0.9);
            padding: 15px 30px;
            border-radius: 8px;
            color: #333;
            font-size: 16px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        #history-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
        }
        
        #history-modal.show {
            display: flex;
        }
        
        #history-content {
            background: rgba(240, 240, 240, 0.95);
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            max-height: 70vh;
            overflow-y: auto;
            color: #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            pointer-events: auto;
        }
        
        #history-content h2 {
            margin-bottom: 20px;
            font-size: 24px;
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
            color: #333;
        }
        
        #history-list {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            color: #000;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            font-size: 18px;
            line-height: 1.8;
            text-align: justify;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .history-item {
            display: inline;
        }
        
        .history-item::after {
            content: ' ';
        }
        
        .history-empty {
            text-align: center;
            color: #999;
            padding: 40px 20px;
            font-style: italic;
        }
        
        .history-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .history-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .history-btn.close {
            background: #333;
            color: #fff;
        }
        
        .history-btn.close:hover {
            background: #555;
            transform: translateY(-1px);
        }
        
        .history-btn.clear {
            background: #dc3545;
            color: #fff;
        }
        
        .history-btn.clear:hover {
            background: #c82333;
            transform: translateY(-1px);
        }
        
        .history-hint {
            font-size: 12px;
            color: #666;
            margin-top: 15px;
            text-align: center;
        }
        
        /* Fish Animation Styles */
        #fish-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            overflow: hidden;
            z-index: 999;
        }
        
        .fish {
            position: absolute;
            font-size: 2rem;
            opacity: 1;
            animation: fish-float 2s ease-out forwards;
            will-change: transform, opacity;
        }
        
        @keyframes fish-float {
            0% {
                transform: translate(0, 0) scale(1) rotate(0deg);
                opacity: 1;
            }
            70% {
                transform: translate(30px, -100px) scale(1.1) rotate(5deg);
                opacity: 0.9;
            }
            100% {
                transform: translate(80px, -200px) scale(1.2) rotate(10deg);
                opacity: 0;
            }
        }
        
        @keyframes fish-arc {
            0% {
                transform: translate(0, 0) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: translate(60px, -100px) rotate(10deg);
                opacity: 0.9;
            }
            100% {
                transform: translate(120px, -200px) rotate(20deg);
                opacity: 0;
            }
        }
        
        .fish.shark {
            font-size: 3.2rem;
            animation-duration: 2s;
            text-shadow: 0 4px 8px rgba(0,0,0,0.5);
            transform-origin: center;
        }

        /* Personal sidebar styles */
        #personal-sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 320px;
            max-width: 80%;
            background: rgba(255,255,255,0.98);
            /* hidden state: no shadow and fully translated off-screen */
            box-shadow: none;
            transform: translateX(-100%);
            transition: transform 0.28s ease, opacity 0.28s ease;
            z-index: 1500;
            display: flex;
            align-items: stretch;
            pointer-events: none; /* disable while hidden */
            overflow: hidden;
        }

        #personal-sidebar.show {
            transform: translateX(0);
            box-shadow: 2px 0 18px rgba(0,0,0,0.12);
            pointer-events: auto;
        }

        #personal-sidebar-inner { padding: 18px; width:100%; display:flex; flex-direction:column; }
        #personal-sidebar-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; }
        #personal-list { overflow:auto; flex:1; padding-right:6px; }
        .personal-item { padding:8px 10px; border-radius:8px; cursor:pointer; margin-bottom:8px; background:transparent; transition:background 0.12s; }
        .personal-item:hover { background: rgba(0,0,0,0.04); }
        .personal-item-title { font-weight:600; color:#111; }
        .personal-item-time { font-size:12px; color:#666; }
        #personal-detail { margin-top:12px; border-top:1px solid #eee; padding-top:12px; }
        #sidebar-close { background:transparent; border:none; font-size:16px; cursor:pointer; color:#666; }

        /* Hide the sidebar when not active via aria-hidden */
        #personal-sidebar[aria-hidden="true"] { opacity: 0.98; }

        /* Left edge toggle and sensor */
        #personal-sidebar-toggle {
            position: fixed;
            left: 8px;
            top: 50%;
            transform: translateY(-50%) translateX(-6px);
            width: 36px;
            height: 56px;
            background: rgba(255,255,255,0.0); /* visually hidden */
            border-radius: 8px;
            border: none;
            box-shadow: none;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1600;
            cursor: pointer;
            transition: transform 0.18s ease, opacity 0.18s ease;
            padding-left: 4px;
            opacity: 0; /* start fully hidden */
            pointer-events: none; /* avoid accidental clicks when hidden */
        }

        /* When sidebar is visible, reveal the chevron briefly */
        #personal-sidebar.show ~ #personal-sidebar-toggle {
            opacity: 1;
            transform: translateY(-50%) translateX(0);
            background: rgba(255,255,255,0.9);
            border: 1px solid rgba(0,0,0,0.06);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            pointer-events: auto;
        }

        /* When sidebar is open, rotate the chevron */
        #personal-sidebar.show ~ #personal-sidebar-toggle svg { transform: rotate(180deg); transition: transform 0.18s ease; }

        /* Hidden larger invisible sensor area for extra sensitivity */
        #left-sensor-area {
            position: fixed;
            left: 0;
            top: 0;
            width: 140px; /* more sensitive: 140px wide activation area */
            height: 100vh;
            z-index: 1550;
            pointer-events: none; /* allow clicks to pass through, we'll use mousemove on document */
        }
        
        /* Authentication Modal Styles */
        .auth-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            padding: 20px;
        }
        
        .auth-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 400px;
            text-align: center;
        }
        
        .auth-container .logo {
            font-size: 2.5rem;
            font-weight: 300;
            color: #333;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }
        
        .auth-container .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }
        
        .auth-tabs {
            display: flex;
            margin-bottom: 30px;
            border-radius: 10px;
            overflow: hidden;
            background: #f5f5f5;
        }
        
        .auth-tabs .tab {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            color: #666;
        }
        
        .auth-tabs .tab.active {
            background: #667eea;
            color: white;
        }
        
        .auth-form {
            display: none;
        }
        
        .auth-form.active {
            display: block;
        }
        
        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }
        
        .form-group input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e1e1;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
            box-sizing: border-box;
        }
        
        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .auth-button {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin-bottom: 15px;
        }
        
        .auth-button:hover {
            transform: translateY(-2px);
        }
        
        .auth-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .guest-button {
            width: 100%;
            padding: 12px;
            background: transparent;
            color: #667eea;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .guest-button:hover {
            background: #667eea;
            color: white;
        }
        
        .divider {
            margin: 20px 0;
            text-align: center;
            color: #999;
            position: relative;
        }
        
        .divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: #e1e1e1;
        }
        
        .divider span {
            background: rgba(255, 255, 255, 0.95);
            padding: 0 15px;
        }
        
        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }
        
        .success-message {
            background: #e8f5e8;
            color: #2e7d32;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }
        /* Welcome overlay styles */
        .welcome-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.45);
            backdrop-filter: blur(10px) saturate(120%);
            -webkit-backdrop-filter: blur(10px) saturate(120%);
            z-index: 4000;
            pointer-events: auto;
            transition: opacity 0.45s ease, transform 0.45s ease;
        }

        .welcome-overlay.hidden { opacity: 0; visibility: hidden; transform: translateY(-6px); pointer-events: none; }

        .welcome-card {
            width: min(920px, 92%);
            max-width: 1100px;
            padding: 48px 36px;
            border-radius: 18px;
            /* Remove the white card background so words sit directly on the blurred backdrop */
            background: transparent;
            box-shadow: none;
            text-align: center;
            position: relative;
            overflow: visible;
        }

        .welcome-title {
            font-family: 'Courier New', Courier, monospace;
            font-size: clamp(44px, 8vw, 110px);
            line-height: 1;
            color: #111;
            font-weight: 700;
            margin-bottom: 18px;
            text-shadow: 0 12px 36px rgba(0,0,0,0.08);
            letter-spacing: 0.6px;
        }

        .welcome-subtitle {
            font-family: Arial, sans-serif;
            font-size: clamp(18px, 2.6vw, 28px);
            color: #444;
            margin-bottom: 28px;
            opacity: 0.95;
        }

        .welcome-controls { display:flex; gap:12px; justify-content:center; }

        .welcome-btn {
            padding: 12px 18px;
            border-radius: 12px;
            border: none;
            font-size: 15px;
            cursor: pointer;
            background: #1976d2;
            color: #fff;
            box-shadow: 0 8px 18px rgba(25,118,210,0.18);
        }

        .welcome-btn.secondary {
            background: transparent;
            color: #1976d2;
            border: 1px solid rgba(25,118,210,0.12);
            box-shadow: none;
        }

        /* Small decorative floating chars inside the welcome card */
        .welcome-floating { position:absolute; inset:0; pointer-events:none; }
    .welcome-floating .char { font-size: clamp(24px, 4vw, 48px); opacity:0.95; text-shadow:0 0 18px rgba(0,0,0,0.08); transition: opacity 2.4s ease, transform 2.4s ease; }

        /* Typewriter caret */
        .typewriter-caret::after {
            content: "|";
            display: inline-block;
            margin-left: 6px;
            opacity: 0.95;
            animation: welcome-blink 1s steps(2, start) infinite;
            color: #1976d2;
            transform: translateY(-2px);
        }

        @keyframes welcome-blink {
            0% { opacity: 1 }
            50% { opacity: 0 }
            100% { opacity: 1 }
        }
    </style>
</head>
<body>
    <div id="personal-popup-overlay">
        <div id="personal-popup">
            <button id="personal-popup-close" title="Close">&times;</button>
            <div id="personal-popup-content"></div>
        </div>
    </div>
    <div id="courier-reminder">Start typing anywhere...</div>
    <!-- Forest Background -->
    <div id="forest-bg" class="svg-background">
        <svg viewBox="0 0 1200 800" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="forestGrad1" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#a8e6cf;stop-opacity:0.7" />
                    <stop offset="50%" style="stop-color:#dcedc8;stop-opacity:0.5" />
                    <stop offset="100%" style="stop-color:#c8e6c9;stop-opacity:0.8" />
                </linearGradient>
                <linearGradient id="forestGrad2" x1="100%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#aed581;stop-opacity:0.6" />
                    <stop offset="100%" style="stop-color:#b2dfdb;stop-opacity:0.7" />
                </linearGradient>
                <radialGradient id="forestGrad3">
                    <stop offset="0%" style="stop-color:#c5e1a5;stop-opacity:0.8" />
                    <stop offset="100%" style="stop-color:#a5d6a7;stop-opacity:0.4" />
                </radialGradient>
                <radialGradient id="forestGrad4">
                    <stop offset="0%" style="stop-color:#f1f8e9;stop-opacity:0.9" />
                    <stop offset="100%" style="stop-color:#dcedc8;stop-opacity:0.3" />
                </radialGradient>
            </defs>
            <!-- Organic blob shapes -->
            <path d="M 150 250 Q 200 100 350 180 T 420 320 Q 380 450 250 400 T 150 250 Z" 
                  fill="url(#forestGrad1)" 
                  style="animation: floatForest1 12s ease-in-out infinite;">
                <animateTransform attributeName="transform" type="rotate" 
                    from="0 250 300" to="15 250 300" dur="20s" repeatCount="indefinite"/>
            </path>
            
            <ellipse cx="700" cy="200" rx="180" ry="250" 
                     fill="url(#forestGrad2)" 
                     style="animation: floatForest2 15s ease-in-out infinite;" 
                     transform="rotate(-25 700 200)"/>
            
            <path d="M 850 400 C 900 350 1000 380 1050 450 S 1000 600 920 580 Q 850 550 820 500 T 850 400 Z" 
                  fill="url(#forestGrad3)" 
                  style="animation: floatForest3 10s ease-in-out infinite;">
                <animateTransform attributeName="transform" type="rotate" 
                    from="0 900 500" to="-20 900 500" dur="25s" repeatCount="indefinite"/>
            </path>
            
            <circle cx="300" cy="650" r="120" fill="url(#forestGrad4)" 
                    style="animation: floatForest1 18s ease-in-out infinite reverse;"/>
            
            <path d="M 500 500 Q 600 450 650 550 T 700 700 Q 600 750 520 680 T 500 500 Z" 
                  fill="url(#forestGrad1)" 
                  opacity="0.6"
                  style="animation: floatForest2 14s ease-in-out infinite;"/>
            
            <ellipse cx="100" cy="100" rx="100" ry="150" 
                     fill="url(#forestGrad3)" 
                     style="animation: floatForest3 16s ease-in-out infinite;" 
                     transform="rotate(45 100 100)"/>
        </svg>
    </div>
    
    <!-- Ocean Background -->
    <div id="ocean-bg" class="svg-background">
        <svg viewBox="0 0 1200 800" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid slice">
            <defs>
                <linearGradient id="oceanGrad1" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#e1f5fe;stop-opacity:0.8" />
                    <stop offset="50%" style="stop-color:#b3e5fc;stop-opacity:0.6" />
                    <stop offset="100%" style="stop-color:#81d4fa;stop-opacity:0.7" />
                </linearGradient>
                <linearGradient id="oceanGrad2" x1="30%" y1="0%" x2="70%" y2="100%">
                    <stop offset="0%" style="stop-color:#b2ebf2;stop-opacity:0.7" />
                    <stop offset="50%" style="stop-color:#80deea;stop-opacity:0.5" />
                    <stop offset="100%" style="stop-color:#4dd0e1;stop-opacity:0.8" />
                </linearGradient>
                <radialGradient id="oceanGrad3" cx="50%" cy="50%">
                    <stop offset="0%" style="stop-color:#e0f7fa;stop-opacity:0.9" />
                    <stop offset="50%" style="stop-color:#b3e5fc;stop-opacity:0.6" />
                    <stop offset="100%" style="stop-color:#64b5f6;stop-opacity:0.3" />
                </radialGradient>
                <radialGradient id="oceanGrad4" cx="50%" cy="50%">
                    <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.7" />
                    <stop offset="30%" style="stop-color:#e1f5fe;stop-opacity:0.6" />
                    <stop offset="100%" style="stop-color:#81d4fa;stop-opacity:0.4" />
                </radialGradient>
                <radialGradient id="oceanGrad5" cx="50%" cy="50%">
                    <stop offset="0%" style="stop-color:#f1f8fb;stop-opacity:0.8" />
                    <stop offset="60%" style="stop-color:#b3e5fc;stop-opacity:0.5" />
                    <stop offset="100%" style="stop-color:#4fc3f7;stop-opacity:0.3" />
                </radialGradient>
                <linearGradient id="oceanGrad6" x1="0%" y1="100%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#b3e5fc;stop-opacity:0.6" />
                    <stop offset="100%" style="stop-color:#e1f5fe;stop-opacity:0.7" />
                </linearGradient>
            </defs>
            
            <!-- Full background base layer -->
            <rect width="1200" height="800" fill="url(#oceanGrad6)" opacity="0.4"/>
            
            <!-- Top area coverage -->
            <ellipse cx="200" cy="100" rx="250" ry="200" 
                     fill="url(#oceanGrad4)" 
                     opacity="0.6"
                     style="animation: waveOcean3 11s ease-in-out infinite;"/>
            
            <ellipse cx="600" cy="50" rx="300" ry="180" 
                     fill="url(#oceanGrad5)" 
                     opacity="0.5"
                     style="animation: waveOcean1 13s ease-in-out infinite;">
                <animateTransform attributeName="transform" type="rotate" 
                    from="0 600 50" to="8 600 50" dur="16s" repeatCount="indefinite"/>
            </ellipse>
            
            <ellipse cx="1000" cy="120" rx="280" ry="220" 
                     fill="url(#oceanGrad3)" 
                     opacity="0.6"
                     style="animation: waveOcean2 12s ease-in-out infinite;"/>
            
            <!-- Large central round shapes -->
            <circle cx="600" cy="400" r="250" 
                    fill="url(#oceanGrad3)" 
                    style="animation: waveOcean3 10s ease-in-out infinite;">
                <animateTransform attributeName="transform" type="scale" 
                    values="1;1.1;0.95;1" dur="10s" repeatCount="indefinite"
                    additive="sum"/>
            </circle>
            
            <ellipse cx="300" cy="350" rx="200" ry="240" 
                     fill="url(#oceanGrad4)" 
                     style="animation: waveOcean1 12s ease-in-out infinite reverse;">
                <animateTransform attributeName="transform" type="rotate" 
                    from="0 300 350" to="10 300 350" dur="15s" repeatCount="indefinite"/>
            </ellipse>
            
            <ellipse cx="950" cy="400" rx="220" ry="190" 
                     fill="url(#oceanGrad5)" 
                     style="animation: waveOcean2 13s ease-in-out infinite;">
                <animateTransform attributeName="transform" type="rotate" 
                    from="0 950 400" to="-8 950 400" dur="14s" repeatCount="indefinite"/>
            </ellipse>
            
            <!-- Additional middle area shapes -->
            <circle cx="150" cy="400" r="120" 
                    fill="url(#oceanGrad3)" 
                    opacity="0.7"
                    style="animation: waveOcean3 9s ease-in-out infinite;"/>
            
            <circle cx="1050" cy="300" r="140" 
                    fill="url(#oceanGrad4)" 
                    opacity="0.65"
                    style="animation: waveOcean1 14s ease-in-out infinite reverse;"/>
            
            <ellipse cx="450" cy="200" rx="160" ry="130" 
                     fill="url(#oceanGrad5)" 
                     opacity="0.6"
                     style="animation: waveOcean2 10s ease-in-out infinite;"/>
            
            <ellipse cx="800" cy="250" rx="140" ry="170" 
                     fill="url(#oceanGrad1)" 
                     opacity="0.6"
                     style="animation: waveOcean3 11s ease-in-out infinite;"/>
            
            <!-- Bottom wave layers - full coverage -->
            <path d="M 0 600 Q 150 550 300 590 T 600 570 Q 900 550 1200 590 L 1200 800 L 0 800 Z" 
                  fill="url(#oceanGrad2)" 
                  opacity="0.7"
                  style="animation: waveOcean2 10s ease-in-out infinite;"/>
            
            <path d="M 0 500 Q 200 450 400 480 T 800 460 Q 1000 470 1200 450 L 1200 800 L 0 800 Z" 
                  fill="url(#oceanGrad1)" 
                  opacity="0.6"
                  style="animation: waveOcean1 9s ease-in-out infinite;"/>
            
            <!-- Flowing organic shapes for coverage -->
            <path d="M 100 650 Q 200 600 300 640 Q 350 680 300 730 Q 250 770 150 750 Q 50 720 100 650 Z" 
                  fill="url(#oceanGrad2)" 
                  opacity="0.5"
                  style="animation: waveOcean2 10s ease-in-out infinite;"/>
            
            <path d="M 950 550 Q 1050 510 1120 570 Q 1150 630 1100 690 Q 1030 730 970 680 Q 920 620 950 550 Z" 
                  fill="url(#oceanGrad1)" 
                  opacity="0.6"
                  style="animation: waveOcean3 11s ease-in-out infinite;"/>
            
            <!-- Top flowing accent waves -->
            <path d="M 0 200 Q 300 170 600 190 T 1200 180" 
                  stroke="url(#oceanGrad4)" 
                  stroke-width="80" 
                  fill="none" 
                  opacity="0.4"
                  style="animation: waveOcean1 15s ease-in-out infinite;"/>
            
            <path d="M 0 300 Q 250 270 500 290 T 1000 280 Q 1100 285 1200 290" 
                  stroke="url(#oceanGrad5)" 
                  stroke-width="70" 
                  fill="none" 
                  opacity="0.35"
                  style="animation: waveOcean2 13s ease-in-out infinite;"/>
            
            <!-- Corner coverage shapes -->
            <ellipse cx="50" cy="50" rx="120" ry="100" 
                     fill="url(#oceanGrad3)" 
                     opacity="0.5"
                     style="animation: waveOcean3 10s ease-in-out infinite;"/>
            
            <ellipse cx="1150" cy="750" rx="150" ry="120" 
                     fill="url(#oceanGrad4)" 
                     opacity="0.6"
                     style="animation: waveOcean1 11s ease-in-out infinite;"/>
        </svg>
    </div>
    
    <!-- Mountain Background -->
    <div id="mountain-bg" class="svg-background">
        <svg viewBox="0 0 1200 800" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="mountainGrad1" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#f3e5f5;stop-opacity:0.8" />
                    <stop offset="50%" style="stop-color:#e1bee7;stop-opacity:0.6" />
                    <stop offset="100%" style="stop-color:#ce93d8;stop-opacity:0.7" />
                </linearGradient>
                <linearGradient id="mountainGrad2" x1="100%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#f8bbd0;stop-opacity:0.7" />
                    <stop offset="100%" style="stop-color:#d1c4e9;stop-opacity:0.6" />
                </linearGradient>
                <radialGradient id="mountainGrad3">
                    <stop offset="0%" style="stop-color:#fce4ec;stop-opacity:0.9" />
                    <stop offset="100%" style="stop-color:#b39ddb;stop-opacity:0.4" />
                </radialGradient>
                <linearGradient id="mountainGrad4" x1="50%" y1="0%" x2="50%" y2="100%">
                    <stop offset="0%" style="stop-color:#ede7f6;stop-opacity:0.8" />
                    <stop offset="100%" style="stop-color:#ba68c8;stop-opacity:0.5" />
                </linearGradient>
            </defs>
            <!-- Angular, crystalline forms -->
            <path d="M 50 700 L 180 400 L 280 550 L 420 300 L 520 700 Z" 
                  fill="url(#mountainGrad1)" 
                  style="animation: driftMountain1 14s ease-in-out infinite;">
                <animateTransform attributeName="transform" type="skewX" 
                    from="0" to="5" dur="18s" repeatCount="indefinite"/>
            </path>
            
            <path d="M 350 700 L 500 250 L 620 450 L 750 180 L 880 700 Z" 
                  fill="url(#mountainGrad2)" 
                  style="animation: driftMountain2 16s ease-in-out infinite;"/>
            
            <polygon points="700,700 850,350 950,500 1100,280 1200,700" 
                     fill="url(#mountainGrad3)" 
                     style="animation: driftMountain3 13s ease-in-out infinite;"/>
            
            <path d="M 200 300 L 350 100 L 450 250 L 550 50 L 600 300 Q 500 350 400 320 T 200 300 Z" 
                  fill="url(#mountainGrad4)" 
                  opacity="0.7"
                  style="animation: driftMountain1 20s ease-in-out infinite reverse;"/>
            
            <ellipse cx="900" cy="550" rx="120" ry="180" 
                     fill="url(#mountainGrad1)" 
                     style="animation: driftMountain2 11s ease-in-out infinite;" 
                     transform="rotate(30 900 550)"/>
            
            <path d="M 100 500 Q 200 450 280 520 L 350 400 Q 400 480 420 550 T 350 650 Q 250 680 180 620 T 100 500 Z" 
                  fill="url(#mountainGrad3)" 
                  opacity="0.6"
                  style="animation: driftMountain3 17s ease-in-out infinite;"/>
            
            <polygon points="600,600 720,420 800,550 900,380 1000,600" 
                     fill="url(#mountainGrad2)" 
                     opacity="0.5"
                     style="animation: driftMountain1 15s ease-in-out infinite;"/>
        </svg>
    </div>
    
    <!-- 鱼的容器 -->
    <div id="fish-layer" aria-hidden="true">
    </div>
    
    <div id="canvas-container"></div>
    
    <!-- Welcome overlay: two pages -->
    <div id="welcome-overlay" class="welcome-overlay hidden" aria-hidden="true">
        <div class="welcome-card" role="dialog" aria-modal="true" aria-label="Welcome to CalmType">
            <div class="welcome-floating" id="welcome-floating"></div>

            <div class="welcome-page" data-page="1">
                <div class="welcome-title" id="welcome-title-1">Hi, This is CalmType</div>
                <div class="welcome-subtitle">A calm typing experience — take your time.</div>
            </div>

            <div class="welcome-page" data-page="2" style="display:none;">
                <div class="welcome-title" id="welcome-title-2">Start typing anywhere.</div>
                <div class="welcome-subtitle">Type to create soft floating characters and relax.</div>
            </div>

            <div class="welcome-controls">
                <button class="welcome-btn" id="welcome-next">Next</button>
                <button class="welcome-btn secondary" id="welcome-skip">Skip</button>
            </div>
        </div>
    </div>
    
    <!-- Personal History Sidebar -->
    <aside id="personal-sidebar" aria-hidden="true">
        <div id="personal-sidebar-inner">
            <div id="personal-sidebar-header">
                <strong>Personal History</strong>
                <button id="sidebar-close" title="Close" aria-label="Close">✕</button>
            </div>
            <div id="personal-list" role="list"></div>
            <div id="personal-detail" aria-live="polite">
                <div id="personal-detail-title"></div>
                <div id="personal-detail-time" style="font-size:12px;color:#666;margin-bottom:8px;"></div>
                <div id="personal-detail-text" style="font-family:Arial,sans-serif; font-style:italic; color:#000; white-space:pre-wrap;"></div>
                <div style="margin-top:12px; display:flex; gap:8px;">
                    <button id="personal-delete" class="history-btn clear">Delete</button>
                </div>
            </div>
        </div>
    </aside>
    <!-- Sidebar toggle (small angle icon) -->
    <button id="personal-sidebar-toggle" title="Open personal history" aria-label="Open personal history">
        <svg viewBox="0 0 24 24" width="18" height="18" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="8 4 16 12 8 20" stroke-linecap="round" stroke-linejoin="round" />
        </svg>
    </button>
    <div id="left-sensor-area" aria-hidden="true"></div>
    
    <button id="background-toggle" title="Change Background">
        <svg class="icon-svg" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <rect x="3" y="3" width="18" height="18" rx="2" fill="none" stroke="currentColor" stroke-width="2"/>
        </svg>
    </button>
    
    <button id="volume-control" title="Volume Control">
        <svg class="icon-svg" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z" fill="currentColor"/>
        </svg>
    </button>

    <button id="fish-toggle" title="Toggle Fish">
        <!-- Inlined project fish icon (scaled by .icon-svg). Body uses currentColor so it matches other icons; eye kept white for contrast. -->
        <svg class="icon-svg" viewBox="0 0 433.46 132.8" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" preserveAspectRatio="xMidYMid meet">
            <path d="M.04,62.77c3.17-30.21,185.19-73.94,312.12-1.77,49.1,27.92,78.55,66.69,101.06,55.15,29.26-15.02,25.42-104.13-2.77-115.09-30.9-12.01-60.71,81.6-149.8,117.19C147.29,163.53-2.94,91.26.04,62.77Z" fill="currentColor"/>
            <circle cx="55.54" cy="55.38" r="6.25" fill="#fff" />
        </svg>
    </button>
    <button id="audio-control" title="Toggle Music">♪</button>
    <audio id="bg-audio" preload="auto" loop></audio>
    
    <div id="volume-slider-container">
        <input type="range" id="volume-slider-vertical" min="0" max="100" value="50" orient="vertical">
        <span id="volume-value">50%</span>
    </div>
    
    <div id="controls" class="collapsed">
        <button id="toggle-btn">☰</button>
        <div id="controls-content">
            <h3>Font Controls</h3>
            
            <div class="section-label">Select Font:</div>
            <select id="font-select">
                <option value="Courier New, monospace">Courier New</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="Verdana, sans-serif">Verdana</option>
                <option value="Impact, sans-serif">Impact</option>
                <option value="Comic Sans MS, cursive">Comic Sans MS</option>
            </select>
            
            <div class="divider"></div>
            
            <div class="section-label">Font Size: <span class="slider-value" id="size-value">80px</span></div>
            <input type="range" id="size-slider" min="40" max="200" value="80" step="10">
            
            <div class="divider"></div>
            
            <div class="section-label">Text Color:</div>
            <input type="color" id="color-picker" value="#000000">
            
            <div class="divider"></div>
            
            <div class="section-label">Or Upload Custom Font:</div>
            <input type="file" id="font-upload" accept=".ttf,.otf" />
            <div class="info">Upload .ttf or .otf file</div>
            
            <div class="divider"></div>
            <h3>Background Music</h3>
            <div class="section-label">Assign music to a background:</div>
            <select id="audio-bg-select">
                <option value="none">None</option>
                <option value="forest">Forest</option>
                <option value="ocean">Ocean</option>
                <option value="mountain">Mountain</option>
            </select>
            <div style="margin-top:8px"></div>
            <input type="file" id="audio-upload-file" accept="audio/*" />
            <div style="margin:8px 0;">or</div>
            <input type="url" id="audio-upload-url" placeholder="Paste remote mp3 URL (https://...)" style="width:100%; padding:8px; border-radius:8px; border:1px solid #ddd;" />
            <div style="display:flex; gap:8px; margin-top:8px;">
                <button id="audio-assign-btn" class="history-btn" style="flex:1; background:#333; color:#fff;">Assign</button>
                <button id="audio-remove-btn" class="history-btn clear" style="flex:1;">Remove</button>
            </div>
            <div class="info" id="audio-current-label">No music assigned for current background.</div>
            
            <div class="divider"></div>
            
            <button id="history-btn" style="width: 100%; padding: 12px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 500; margin-top: 10px;">
                📝 My Writing History
            </button>
            
            <button id="logout-btn" style="width: 100%; padding: 12px; background: #ff6b6b; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 500; margin-top: 8px; display: none;">
                🚪 Sign Out
            </button>
        </div>
    </div>
    
    <!-- Authentication Modal -->
    <div id="auth-modal" class="auth-modal">
        <div class="auth-container">
            <div class="logo">Calm Typing</div>
            <div class="subtitle">Choose how you'd like to start</div>
            
            <div class="auth-tabs">
                <button class="tab active" id="login-tab">Sign In</button>
                <button class="tab" id="register-tab">Sign Up</button>
            </div>
            
            <!-- Login Form -->
            <div id="login-form" class="auth-form active">
                <form id="login-form-element">
                    <div class="form-group">
                        <label for="login-username">Username or Email</label>
                        <input type="text" id="login-username" name="username" required>
                    </div>
                    <div class="form-group">
                        <label for="login-password">Password</label>
                        <input type="password" id="login-password" name="password" required>
                    </div>
                    <button type="submit" class="auth-button" id="login-btn">
                        <span id="login-text">Sign In</span>
                        <div id="login-loading" class="loading" style="display: none;"></div>
                    </button>
                </form>
            </div>
            
            <!-- Register Form -->
            <div id="register-form" class="auth-form">
                <form id="register-form-element">
                    <div class="form-group">
                        <label for="register-username">Username</label>
                        <input type="text" id="register-username" name="username" required>
                    </div>
                    <div class="form-group">
                        <label for="register-email">Email</label>
                        <input type="email" id="register-email" name="email" required>
                    </div>
                    <div class="form-group">
                        <label for="register-password">Password</label>
                        <input type="password" id="register-password" name="password" required minlength="6">
                    </div>
                    <button type="submit" class="auth-button" id="register-btn">
                        <span id="register-text">Sign Up</span>
                        <div id="register-loading" class="loading" style="display: none;"></div>
                    </button>
                </form>
            </div>
            
            <div class="divider">
                <span>or</span>
            </div>
            
            <button class="guest-button" id="guest-button">
                Continue as Guest
            </button>
        </div>
    </div>
    
    <div id="instructions">
        Start typing anywhere...
    </div>
    
    <div id="history-modal">
        <div id="history-content">
            <div style="display:flex; gap:12px; margin-bottom:18px;">
                <button id="tab-word-history" class="history-btn" style="flex:1; background:#1976d2; color:#fff;">Word History</button>
                <button id="tab-sentence-revision" class="history-btn" style="flex:1; background:#fff; color:#1976d2; border:1px solid #1976d2;">Sentence Revisions</button>
                <button id="tab-personal-history" class="history-btn" style="flex:1; background:#fff; color:#1976d2; border:1px solid #1976d2;">📝 My Writings</button>
            </div>
            <div id="history-list"></div>
            <div id="sentence-list" style="display:none;"></div>
            <div id="personal-history-list" style="display:none;">
                <div id="personal-history-loading" style="text-align: center; color: #666; padding: 20px;">
                    Loading your writing history...
                </div>
                <div id="personal-history-empty" style="text-align: center; color: #666; padding: 20px; display: none;">
                    <p>No writing history found.</p>
                    <p style="font-size: 14px; margin-top: 8px;">Start typing to build your personal writing collection!</p>
                </div>
            </div>
            <div class="history-buttons">
                <button class="history-btn close" id="close-history">Close</button>
                <button class="history-btn clear" id="clear-history">Clear History</button>
                <button class="history-btn" id="export-history" style="background: #4ecdc4; color: white;">Export</button>
            </div>
            <div class="history-hint">Press Tab to toggle history</div>
        </div>
    </div>
    
    <script>
        // DeepSeek API Configuration
        const DEEPSEEK_CONFIG = {
            apiKey: 'sk-ac8a74958695407982c793531636cb29', // Your DeepSeek API key
            apiUrl: 'https://api.deepseek.com/v1/chat/completions',
            model: 'deepseek-chat',
            maxTokens: 50,
            temperature: 0.7
        };
        
        // Server API Configuration
        const API_BASE = window.location.origin;
        
        // Authentication state
        let isAuthenticated = false;
        let isGuest = false;
        let authToken = null;
        let guestId = null;
        let currentUser = null;
        
        const container = document.getElementById('canvas-container');
        // --- Welcome pages: two-step onboarding overlay ---
        const welcomeOverlay = document.getElementById('welcome-overlay');
        const welcomeFloating = document.getElementById('welcome-floating');
        let _welcomeInterval = null;
        let _welcomePage = 1;
        let _typeTimer = null;
        let _typeIndex = 0;
        let _typeCancel = false;

        /* Backdrop blur handled via CSS using backdrop-filter on the overlay.
           We provide a typewriter effect for the large Courier titles. */

        function showWelcomeOverlay() {
            if (!welcomeOverlay) return;
            welcomeOverlay.classList.remove('hidden');
            welcomeOverlay.setAttribute('aria-hidden', 'false');
            startWelcomeFloating();
            // start typing for current page
            startTypeForPage(_welcomePage);
        }

        function hideWelcomeOverlay() {
            if (!welcomeOverlay) return;
            welcomeOverlay.classList.add('hidden');
            welcomeOverlay.setAttribute('aria-hidden', 'true');
            stopWelcomeFloating();
            stopTypewriter();
            setTimeout(enableCourierReminderAfterWelcome, 400);
        }

        function startWelcomeFloating() {
            stopWelcomeFloating();
            if (!welcomeFloating) return;
            _welcomeInterval = setInterval(() => spawnWelcomeChar(), 420);
        }

        function stopWelcomeFloating() {
            if (_welcomeInterval) { clearInterval(_welcomeInterval); _welcomeInterval = null; }
            if (welcomeFloating) { welcomeFloating.innerHTML = ''; }
        }

        function spawnWelcomeChar() {
            if (!welcomeFloating) return;
            const chars = ['•', '~', '·', '˚', '•', '.', '•'];
            const ch = chars[Math.floor(Math.random() * chars.length)];
            const el = document.createElement('div');
            el.className = 'char';
            el.textContent = ch;
            const rect = welcomeFloating.getBoundingClientRect();
            const x = Math.random() * (rect.width - 40) + 20;
            const y = Math.random() * (rect.height - 40) + 20;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            const size = Math.round(18 + Math.random() * 48);
            el.style.fontSize = size + 'px';
            el.style.opacity = '0.95';
            el.style.transform = 'translate(-50%, -50%)';
            welcomeFloating.appendChild(el);
            // linger longer before fading and removal for a calmer effect
            setTimeout(() => { el.style.opacity = '0'; }, 1200 + Math.random() * 1200);
            setTimeout(() => { try { el.remove(); } catch (e) {} }, 2800 + Math.random() * 1200);
        }

        function showPage(n) {
            document.querySelectorAll('.welcome-page').forEach(p => p.style.display = 'none');
            const p = document.querySelector(`.welcome-page[data-page="${n}"]`);
            if (p) p.style.display = '';
            _welcomePage = n;
            // start typing for that page
            startTypeForPage(n);
        }

        function nextWelcomePage() {
            if (_welcomePage === 1) { showPage(2); return; }
            dismissWelcome(true);
        }

        function dismissWelcome(persist) {
            hideWelcomeOverlay();
            try { if (persist) localStorage.setItem('calm_welcome_dismissed', '1'); } catch (e) {}
        }

        // Typewriter implementation
        function startTypeForPage(pageNum) {
            stopTypewriter();
            _typeCancel = false;
            const titleEl = document.querySelector(`.welcome-page[data-page="${pageNum}"] .welcome-title`);
            if (!titleEl) return;
            // Use data attribute for full text (or read current innerText)
            const full = titleEl.getAttribute('data-full') || titleEl.textContent || '';
            // store full text in data-full and clear visible text
            titleEl.setAttribute('data-full', full.trim());
            titleEl.textContent = '';
            titleEl.classList.add('typewriter-caret');
            const speed = 45 + Math.floor(Math.random() * 40); // 45-85ms per char
            _typeIndex = 0;
            _typeTimer = setInterval(() => {
                if (_typeCancel) { stopTypewriter(); return; }
                const fullText = titleEl.getAttribute('data-full') || '';
                if (_typeIndex >= fullText.length) { stopTypewriter(); return; }
                titleEl.textContent += fullText.charAt(_typeIndex);
                _typeIndex++;
            }, speed);
        }

        function stopTypewriter() {
            if (_typeTimer) { clearInterval(_typeTimer); _typeTimer = null; }
            _typeCancel = true;
            document.querySelectorAll('.welcome-title.typewriter-caret').forEach(el => el.classList.remove('typewriter-caret'));
        }

        // Wire up overlay controls after DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            const next = document.getElementById('welcome-next');
            const skip = document.getElementById('welcome-skip');
            if (next) next.addEventListener('click', nextWelcomePage);
            if (skip) skip.addEventListener('click', function() { dismissWelcome(true); });

            if (welcomeOverlay) {
                welcomeOverlay.addEventListener('click', function(e) {
                    if (e.target === welcomeOverlay) { dismissWelcome(true); }
                });
            }

            document.addEventListener('keydown', function(e) {
                if (!welcomeOverlay || welcomeOverlay.classList.contains('hidden')) return;
                if (e.key === 'Enter') { nextWelcomePage(); }
                if (e.key === 'Escape') { dismissWelcome(true); }
            });

            // Welcome overlay will be shown after the auth modal is closed (hideAuthModal)
        });
        const fontUpload = document.getElementById('font-upload');
        const fontSelect = document.getElementById('font-select');
        const colorPicker = document.getElementById('color-picker');
        const sizeSlider = document.getElementById('size-slider');
        const sizeValue = document.getElementById('size-value');
        const toggleBtn = document.getElementById('toggle-btn');
        const controls = document.getElementById('controls');
        const historyModal = document.getElementById('history-modal');
        const historyList = document.getElementById('history-list');
        const closeHistoryBtn = document.getElementById('close-history');
        const clearHistoryBtn = document.getElementById('clear-history');
        const backgroundToggle = document.getElementById('background-toggle');
        const forestBg = document.getElementById('forest-bg');
        const oceanBg = document.getElementById('ocean-bg');
        const mountainBg = document.getElementById('mountain-bg');
        const volumeControl = document.getElementById('volume-control');
        const volumeSliderContainer = document.getElementById('volume-slider-container');
        const volumeSlider = document.getElementById('volume-slider-vertical');
        const volumeValue = document.getElementById('volume-value');
    const fishToggle = document.getElementById('fish-toggle');
    const audioControl = document.getElementById('audio-control');
    const bgAudio = document.getElementById('bg-audio');
        
        let customFontFamily = 'Courier New, monospace';
        let textColor = '#000000';
        let fontSize = 80;
        let charPosition = 0;
        let activeChars = 0;
        let resetTimeout;
        let currentLineChars = [];
        let totalLineWidth = 0;
        let currentWord = '';
    let currentSentence = '';
        let typingHistory = [];
    let sentenceHistory = [];
        let currentBackground = 0; // 0 = none, 1 = forest, 2 = ocean, 3 = mountain
        let currentVolume = 0.5;
        
        const backgrounds = [
            { element: null, icon: createRectIcon(), name: 'none' },
            { element: forestBg, icon: createTreeIcon(), name: 'forest' },
            { element: oceanBg, icon: createWaveIcon(), name: 'ocean' },
            { element: mountainBg, icon: createMountainIcon(), name: 'mountain' }
        ];
        
        // Create SVG icons
        function createRectIcon() {
            return '<svg class="icon-svg" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="3" width="18" height="18" rx="2" fill="none" stroke="currentColor" stroke-width="2"/></svg>';
        }
        
        function createTreeIcon() {
            return '<svg class="icon-svg" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2L8 8h2v2L6 16h3v6h6v-6h3l-4-6v-2h2L12 2z" fill="currentColor"/></svg>';
        }
        
        function createWaveIcon() {
            return '<svg class="icon-svg" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 12c2 0 2-3 4-3s2 3 4 3 2-3 4-3 2 3 4 3 2-3 4-3M3 18c2 0 2-3 4-3s2 3 4 3 2-3 4-3 2 3 4 3 2-3 4-3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
        }
        
        function createMountainIcon() {
            return '<svg class="icon-svg" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14 6l-3 4.5L8 6 2 19h20L14 6z" fill="currentColor"/></svg>';
        }
        
        // Load history from server or localStorage
        async function loadHistory() {
            // Check if we're running on a server
            if (window.location.protocol === 'file:') {
                // Local file mode - use localStorage only
            const saved = localStorage.getItem('typingHistory');
            if (saved) {
                try {
                    typingHistory = JSON.parse(saved);
                } catch (e) {
                    typingHistory = [];
                }
            }
                return;
            }
            
            if (isAuthenticated) {
                try {
                    const response = await fetch(`${API_BASE}/user/data/typing_history`, {
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });
                    if (response.ok) {
                        const result = await response.json();
                        typingHistory = result.data || [];
                        return;
                    }
                } catch (error) {
                    console.log('Failed to load from server, using local storage');
                }
            } else if (isGuest) {
                try {
                    const response = await fetch(`${API_BASE}/api/guest/history`, {
                        headers: {
                            'x-guest-id': guestId
                        }
                    });
                    if (response.ok) {
                        const result = await response.json();
                        typingHistory = result.data || [];
                        return;
                    }
                } catch (error) {
                    console.log('Failed to load guest data, using local storage');
                }
            }
            
            // Fallback to localStorage
            const saved = localStorage.getItem('typingHistory');
            if (saved) {
                try {
                    typingHistory = JSON.parse(saved);
                } catch (e) {
                    typingHistory = [];
                }
            }
        }
        
        // Save individual history entry to server or localStorage
        async function saveIndividualHistory(historyEntry) {
            // Check if we're running on a server
            if (window.location.protocol === 'file:') {
                // Local file mode - use localStorage only
                const localHistory = JSON.parse(localStorage.getItem('typingHistory') || '[]');
                localHistory.push(historyEntry);
                localStorage.setItem('typingHistory', JSON.stringify(localHistory));
                return;
            }
            
            const authToken = localStorage.getItem('authToken');
            const guestId = localStorage.getItem('guestId');
            const isAuthenticated = authToken && localStorage.getItem('user');
            
            if (isAuthenticated) {
                try {
                    await fetch(`${API_BASE}/api/user/history`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(historyEntry)
                    });
                    console.log('Saved to user history:', historyEntry);
                    return;
                } catch (error) {
                    console.log('Failed to save to server, using local storage');
                }
            } else if (guestId) {
                try {
                    await fetch(`${API_BASE}/api/guest/history`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-guest-id': guestId
                        },
                        body: JSON.stringify(historyEntry)
                    });
                    console.log('Saved to guest history:', historyEntry);
                    return;
                } catch (error) {
                    console.log('Failed to save guest data, using local storage');
                }
            }
            
            // Fallback to localStorage
            const localHistory = JSON.parse(localStorage.getItem('typingHistory') || '[]');
            localHistory.push(historyEntry);
            localStorage.setItem('typingHistory', JSON.stringify(localHistory));
        }

        // Save history to server or localStorage (legacy function)
        async function saveHistory() {
            // Check if we're running on a server
            if (window.location.protocol === 'file:') {
                // Local file mode - use localStorage only
                localStorage.setItem('typingHistory', JSON.stringify(typingHistory));
                return;
            }
            
            if (isAuthenticated) {
                try {
                    await fetch(`${API_BASE}/user/data/typing_history`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(typingHistory)
                    });
                    return;
                } catch (error) {
                    console.log('Failed to save to server, using local storage');
                }
            } else if (isGuest) {
                try {
                    await fetch(`${API_BASE}/api/guest/history`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-guest-id': guestId
                        },
                        body: JSON.stringify(typingHistory)
                    });
                    return;
                } catch (error) {
                    console.log('Failed to save guest data, using local storage');
                }
            }
            
            // Fallback to localStorage
            localStorage.setItem('typingHistory', JSON.stringify(typingHistory));
        }
        
        // Add word to history with auto-correction
        async function addToHistory(word) {
            if (word.trim().length > 0) {
                try {
                    // Auto-correct the word before saving
                    const correctedWord = await autoCorrectWord(word.trim());
                    typingHistory.push({
                        text: correctedWord,
                        original: word !== correctedWord ? word : null,
                        timestamp: new Date().toISOString()
                    });
                    // If the word was replaced by an emoji, also add to sentenceHistory as a revised entry
                    if (word !== correctedWord && /[\u2190-\u2BFF\u2600-\u27BF\u1F300-\u1F6FF\u1F900-\u1F9FF\u1F600-\u1F64F\u1F680-\u1F6FF\u1F1E6-\u1F1FF\u2700-\u27BF\u1F191-\u1F251\u1F004-\u1F0CF\u1F170-\u1F171\u1F17E-\u1F17F\u1F18E\u3030\u2B50\u2B06\u2194-\u21AA\u2934-\u2935\u25AA-\u25AB\u25FE-\u25FF\u25B6\u25C0\u25FB-\u25FE\u2600-\u26FF\u1F300-\u1F5FF\u1F600-\u1F64F\u1F680-\u1F6FF\u1F700-\u1F77F\u1F780-\u1F7FF\u1F800-\u1F8FF\u1F900-\u1F9FF\u1FA00-\u1FA6F\u1FA70-\u1FAFF\u2300-\u23FF\u2B05-\u2B07\u2934-\u2935\u25AA-\u25AB\u25FE-\u25FF\u25B6\u25C0\u25FB-\u25FE\u2600-\u26FF\u1F300-\u1F5FF\u1F600-\u1F64F\u1F680-\u1F6FF\u1F700-\u1F77F\u1F780-\u1F7FF\u1F800-\u1F8FF\u1F900-\u1F9FF\u1FA00-\u1FA6F\u1FA70-\u1FAFF\u2300-\u23FF]/.test(correctedWord)) {
                        sentenceHistory.push({
                            text: correctedWord,
                            original: word,
                            timestamp: new Date().toISOString()
                        });
                        saveHistory();
                    }
                    saveHistory();
                    console.log(`Saved to history: ${word} → ${correctedWord}`);
                } catch (error) {
                    // If auto-correction fails, save original word
                    typingHistory.push({
                        text: word,
                        timestamp: new Date().toISOString()
                    });
                    saveHistory();
                    console.log(`Saved original word to history: ${word}`);
                }
            }
        }
        
        // Render word history only
        function renderWordHistory() {
            // Get all words from completed sentences
            const allWords = [];
            sentenceHistory.forEach(sentence => {
                if (sentence.text) {
                    const words = sentence.text.split(/\s+/).filter(word => word.length > 0);
                    words.forEach(word => {
                        allWords.push({
                            text: word,
                            timestamp: sentence.timestamp
                        });
                    });
                }
            });
            
            if (allWords.length === 0) {
                historyList.innerHTML = '<div class="history-empty" style="color: #999; font-style: italic; padding: 40px 20px; text-align: center;">No words typed yet. Complete a sentence to see words here!</div>';
            } else {
                let html = '';
                html += '<div>';
                html += allWords
                    .map(item => item.text)
                    .join(' ');
                html += '</div>';
                historyList.innerHTML = html;
            }
        }

        // Render sentence revision history only
        function renderSentenceHistory() {
            const sentenceList = document.getElementById('sentence-list');
            if (sentenceHistory.length === 0) {
                sentenceList.innerHTML = '<div class="history-empty" style="color: #999; font-style: italic; padding: 40px 20px; text-align: center;">No revised sentences yet. Type a sentence ending with a period to see revisions!</div>';
            } else {
                let html = '';
                html += '<div>';
                html += sentenceHistory.map(item => {
                    // Show revised sentence in italic Arial, black, no highlight
                    return `<span style=\"font-family:Arial,sans-serif; font-style:italic; color:#000; margin-right:8px;\">${item.text}</span>`;
                }).join(' ');
                html += '</div>';
                sentenceList.innerHTML = html;
            }
        }

        // Tab switching logic
        const tabWordHistory = document.getElementById('tab-word-history');
        const tabSentenceRevision = document.getElementById('tab-sentence-revision');
        const tabPersonalHistory = document.getElementById('tab-personal-history');
        const sentenceList = document.getElementById('sentence-list');
        const personalHistoryList = document.getElementById('personal-history-list');
        
        tabWordHistory.addEventListener('click', function() {
            tabWordHistory.style.background = '#1976d2';
            tabWordHistory.style.color = '#fff';
            tabSentenceRevision.style.background = '#fff';
            tabSentenceRevision.style.color = '#1976d2';
            tabSentenceRevision.style.border = '1px solid #1976d2';
            tabPersonalHistory.style.background = '#fff';
            tabPersonalHistory.style.color = '#1976d2';
            tabPersonalHistory.style.border = '1px solid #1976d2';
            historyList.style.display = '';
            sentenceList.style.display = 'none';
            personalHistoryList.style.display = 'none';
            renderWordHistory();
        });
        tabSentenceRevision.addEventListener('click', function() {
            tabSentenceRevision.style.background = '#1976d2';
            tabSentenceRevision.style.color = '#fff';
            tabWordHistory.style.background = '#fff';
            tabWordHistory.style.color = '#1976d2';
            tabWordHistory.style.border = '1px solid #1976d2';
            tabPersonalHistory.style.background = '#fff';
            tabPersonalHistory.style.color = '#1976d2';
            tabPersonalHistory.style.border = '1px solid #1976d2';
            historyList.style.display = 'none';
            sentenceList.style.display = '';
            personalHistoryList.style.display = 'none';
            renderSentenceHistory();
        });
        
        tabPersonalHistory.addEventListener('click', function() {
            tabPersonalHistory.style.background = '#1976d2';
            tabPersonalHistory.style.color = '#fff';
            tabWordHistory.style.background = '#fff';
            tabWordHistory.style.color = '#1976d2';
            tabWordHistory.style.border = '1px solid #1976d2';
            tabSentenceRevision.style.background = '#fff';
            tabSentenceRevision.style.color = '#1976d2';
            tabSentenceRevision.style.border = '1px solid #1976d2';
            historyList.style.display = 'none';
            sentenceList.style.display = 'none';
            personalHistoryList.style.display = '';
            loadPersonalHistory();
        });

        // When opening modal, default to word history
        function renderHistory() {
            tabWordHistory.click();
        }
        // Add sentence to history with DeepSeek revision
        async function addSentenceToHistory(sentence) {
            if (sentence.trim().length > 0) {
                try {
                    const revised = await autoReviseSentence(sentence.trim());
                    const historyEntry = {
                        text: revised,
                        timestamp: new Date().toISOString(),
                        wordCount: revised.split(' ').length
                    };
                    sentenceHistory.push(historyEntry);
                    await saveIndividualHistory(historyEntry);
                    console.log(`Sentence revised: ${sentence} → ${revised}`);
                } catch (error) {
                    const historyEntry = {
                        text: sentence,
                        timestamp: new Date().toISOString(),
                        wordCount: sentence.split(' ').length
                    };
                    sentenceHistory.push(historyEntry);
                    await saveIndividualHistory(historyEntry);
                    console.log(`Saved original sentence to history: ${sentence}`);
                }
            }
        }

        // DeepSeek sentence revision
        async function autoReviseSentence(sentence) {
            // Check if API key is set
            if (DEEPSEEK_CONFIG.apiKey === 'YOUR_DEEPSEEK_API_KEY' || !DEEPSEEK_CONFIG.apiKey) {
                // Fallback: return sentence unchanged
                return sentence;
            }
            try {
                const revised = await callDeepSeekSentenceRevision(sentence);
                return revised;
            } catch (error) {
                return sentence;
            }
        }

        async function callDeepSeekSentenceRevision(sentence) {
            const response = await fetch(DEEPSEEK_CONFIG.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${DEEPSEEK_CONFIG.apiKey}`
                },
                body: JSON.stringify({
                    model: DEEPSEEK_CONFIG.model,
                    messages: [
                        {
                            role: 'user',
                            content: `Please check and revise this sentence for grammar, spelling, and clarity. If it is already correct, return it unchanged. Sentence: \"${sentence}\". Return only the revised sentence, nothing else.`
                        }
                    ],
                    max_tokens: 100,
                    temperature: 0.3
                })
            });
            if (!response.ok) {
                throw new Error(`API request failed: ${response.status}`);
            }
            const data = await response.json();
            const revised = data.choices[0].message.content.trim();
            return revised || sentence;
        }
        
        // Toggle history modal
        function toggleHistory() {
            historyModal.classList.toggle('show');
            const instructions = document.getElementById('instructions');
            const courierReminder = document.getElementById('courier-reminder');
            
            if (historyModal.classList.contains('show')) {
                renderHistory();
                // Hide all typing prompts when history is open
                if (instructions) {
                    instructions.style.display = 'none';
                }
                if (courierReminder) {
                    courierReminder.style.display = 'none';
                }
            } else {
                // Show the typing prompts when history is closed
                if (instructions) {
                    instructions.style.display = 'block';
                }
                if (courierReminder) {
                    courierReminder.style.display = 'block';
                }
            }
        }
        
        // Close history modal
        closeHistoryBtn.addEventListener('click', function() {
            historyModal.classList.remove('show');
            // Show the typing prompts when history is closed
            const instructions = document.getElementById('instructions');
            const courierReminder = document.getElementById('courier-reminder');
            if (instructions) {
                instructions.style.display = 'block';
            }
            if (courierReminder) {
                courierReminder.style.display = 'block';
            }
        });
        
        // Clear history
        clearHistoryBtn.addEventListener('click', function() {
            if (confirm('Are you sure you want to clear all typing history?')) {
                typingHistory = [];
                sentenceHistory = [];
                localStorage.removeItem('typingHistory');
                saveHistory();
                renderHistory();
            }
        });
        
        // History button in controls
        const historyBtn = document.getElementById('history-btn');
        if (historyBtn) {
            historyBtn.addEventListener('click', function() {
                historyModal.classList.add('show');
                // Default to personal history tab
                tabPersonalHistory.click();
            });
        }
        
        // Export history functionality
        const exportHistoryBtn = document.getElementById('export-history');
        if (exportHistoryBtn) {
            exportHistoryBtn.addEventListener('click', function() {
                exportPersonalHistory();
            });
        }
        
        // Logout button functionality
        const logoutBtn = document.getElementById('logout-btn');
        if (logoutBtn) {
            logoutBtn.addEventListener('click', function() {
                logout();
            });
        }
        
        // Close modal when clicking outside
        historyModal.addEventListener('click', function(e) {
            if (e.target === historyModal) {
                historyModal.classList.remove('show');
            }
        });
        
        // Load history on startup
        loadHistory();
        
        // Clear any old random data and initialize clean
        function initializeCleanHistory() {
            // Clear any old random data
            typingHistory = [];
            // Keep sentenceHistory as it contains real data
            saveHistory();
        }
        
        // Initialize clean history on page load
        initializeCleanHistory();

        // --- Personal history (sidebar) storage & UI ---
        let personalHistory = [];

        async function loadPersonalHistory() {
            const loadingDiv = document.getElementById('personal-history-loading');
            const emptyDiv = document.getElementById('personal-history-empty');
            const listDiv = document.getElementById('personal-history-list');
            
            // Show loading state
            loadingDiv.style.display = 'block';
            emptyDiv.style.display = 'none';
            
            try {
                let history = [];
                
                // Check authentication status
                const authToken = localStorage.getItem('authToken');
                const guestId = localStorage.getItem('guestId');
                const isAuthenticated = authToken && localStorage.getItem('user');
                
                console.log('Loading personal history - Auth:', isAuthenticated, 'Guest:', guestId);
                console.log('Auth token:', authToken);
                console.log('User data:', localStorage.getItem('user'));
                
                if (isAuthenticated) {
                    // Load from authenticated user's history
                    try {
                        const url = `${API_BASE}/api/user/history`;
                        console.log('Fetching from URL:', url);
                        console.log('Auth token:', authToken);
                        
                        const response = await fetch(url, {
                            headers: {
                                'Authorization': `Bearer ${authToken}`
                            }
                        });
                        
                        console.log('Response status:', response.status);
                        console.log('Response headers:', response.headers);
                        
                        if (response.ok) {
                            const result = await response.json();
                            history = result.history || [];
                            console.log('Loaded user history:', history.length, 'entries');
                        } else {
                            console.log('Failed to load user history, falling back to local storage');
                            const raw = localStorage.getItem('typingHistory');
                            history = raw ? JSON.parse(raw) : [];
                        }
                    } catch (error) {
                        console.log('Error loading user history, falling back to local storage:', error);
                        const raw = localStorage.getItem('typingHistory');
                        history = raw ? JSON.parse(raw) : [];
                    }
                } else if (guestId) {
                    // Load from guest session
                    try {
                        const response = await fetch(`${API_BASE}/api/guest/history`, {
                            headers: {
                                'x-guest-id': guestId
                            }
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            history = result.history || [];
                            console.log('Loaded guest history:', history.length, 'entries');
                        } else {
                            console.log('Failed to load guest history, falling back to local storage');
                            const raw = localStorage.getItem('typingHistory');
                            history = raw ? JSON.parse(raw) : [];
                        }
                    } catch (error) {
                        console.log('Error loading guest history, falling back to local storage:', error);
                        const raw = localStorage.getItem('typingHistory');
                        history = raw ? JSON.parse(raw) : [];
                    }
                } else {
                    // Load from local storage
                    const raw = localStorage.getItem('typingHistory');
                    history = raw ? JSON.parse(raw) : [];
                    console.log('Loaded local history:', history.length, 'entries');
                }
                
                // Hide loading, show content
                loadingDiv.style.display = 'none';
                
                if (history.length === 0) {
                    emptyDiv.style.display = 'block';
                } else {
                    // Display the history
                    let html = '';
                    history.forEach((entry, index) => {
                        const date = new Date(entry.timestamp || entry.created_at).toLocaleString();
                        const text = entry.text || entry.sentence || '';
                        const wordCount = entry.wordCount || text.split(' ').length;
                        
                        html += `
                            <div style="border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-bottom: 12px; background: white;">
                                <div style="font-size: 14px; color: #666; margin-bottom: 8px;">${date}</div>
                                <div style="font-size: 16px; line-height: 1.5; color: #333;">${text}</div>
                                <div style="font-size: 12px; color: #999; margin-top: 8px;">
                                    ${wordCount} words
                                </div>
                            </div>
                        `;
                    });
                    listDiv.innerHTML = html;
                }
            } catch (error) {
                console.error('Error loading personal history:', error);
                loadingDiv.style.display = 'none';
                emptyDiv.style.display = 'block';
                emptyDiv.innerHTML = '<p>Error loading history. Please try again.</p>';
            }
        }

        function savePersonalHistory() {
            try {
                localStorage.setItem('personalHistory', JSON.stringify(personalHistory));
            } catch (e) {
                console.warn('Failed to save personal history', e);
            }
        }
        
        // Export personal history to text file
        async function exportPersonalHistory() {
            try {
                let history = [];
                
                // Get the same data that's displayed in personal history
                const authToken = localStorage.getItem('authToken');
                const guestId = localStorage.getItem('guestId');
                const isAuthenticated = authToken && localStorage.getItem('user');
                
                if (isAuthenticated) {
                    try {
                        const response = await fetch(`${API_BASE}/api/user/history`, {
                            headers: {
                                'Authorization': `Bearer ${authToken}`
                            }
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            history = result.history || [];
                        } else {
                            const raw = localStorage.getItem('typingHistory');
                            history = raw ? JSON.parse(raw) : [];
                        }
                    } catch (error) {
                        const raw = localStorage.getItem('typingHistory');
                        history = raw ? JSON.parse(raw) : [];
                    }
                } else if (guestId) {
                    try {
                        const response = await fetch(`${API_BASE}/api/guest/history`, {
                            headers: {
                                'x-guest-id': guestId
                            }
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            history = result.history || [];
                        } else {
                            const raw = localStorage.getItem('typingHistory');
                            history = raw ? JSON.parse(raw) : [];
                        }
                    } catch (error) {
                        const raw = localStorage.getItem('typingHistory');
                        history = raw ? JSON.parse(raw) : [];
                    }
                } else {
                    const raw = localStorage.getItem('typingHistory');
                    history = raw ? JSON.parse(raw) : [];
                }
                
                if (history.length === 0) {
                    alert('No writing history to export.');
                    return;
                }
                
                // Create export content
                let exportContent = `My Writing History\n`;
                exportContent += `Generated on: ${new Date().toLocaleString()}\n`;
                exportContent += `Total entries: ${history.length}\n`;
                exportContent += `\n${'='.repeat(50)}\n\n`;
                
                history.forEach((entry, index) => {
                    const date = new Date(entry.timestamp || entry.created_at).toLocaleString();
                    const text = entry.text || entry.sentence || '';
                    const wordCount = entry.wordCount || text.split(' ').length;
                    
                    exportContent += `Entry ${index + 1} - ${date}\n`;
                    exportContent += `Words: ${wordCount}\n`;
                    exportContent += `\n${text}\n\n`;
                    exportContent += `${'-'.repeat(30)}\n\n`;
                });
                
                // Create and download file
                const blob = new Blob([exportContent], { type: 'text/plain' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `my-writing-history-${new Date().toISOString().split('T')[0]}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                console.log('Export completed successfully');
            } catch (error) {
                console.error('Error exporting history:', error);
                alert('Error exporting history. Please try again.');
            }
        }

        function renderPersonalList() {
            const listEl = document.getElementById('personal-list');
            listEl.innerHTML = '';
            if (personalHistory.length === 0) {
                listEl.innerHTML = '<div class="history-empty">No personal entries yet. Save a revised sentence with Cmd/Ctrl+Enter.</div>';
                document.getElementById('personal-detail-title').textContent = '';
                document.getElementById('personal-detail-text').textContent = '';
                document.getElementById('personal-detail-time').textContent = '';
                return;
            }
            personalHistory.slice().reverse().forEach(entry => {
                const item = document.createElement('div');
                item.className = 'personal-item';
                item.dataset.id = entry.id;
                item.innerHTML = `<div class=\"personal-item-title\">${entry.title}</div><div class=\"personal-item-time\">${new Date(entry.timestamp).toLocaleString()}</div>`;
                item.addEventListener('click', () => {
                    selectPersonalEntry(entry.id);
                    showPersonalPopup(entry.text, entry.title, entry.timestamp);
                });
                listEl.appendChild(item);
            });
        // Focused reading popup for personal history
        function showPersonalPopup(text, title, timestamp) {
            const overlay = document.getElementById('personal-popup-overlay');
            const content = document.getElementById('personal-popup-content');
            const closeBtn = document.getElementById('personal-popup-close');
            if (!overlay || !content || !closeBtn) return;
            content.innerHTML = '';
            if (title) {
                const t = document.createElement('div');
                t.style.fontWeight = 'bold';
                t.style.fontSize = '1.1rem';
                t.style.marginBottom = '10px';
                t.textContent = title;
                content.appendChild(t);
            }
            if (timestamp) {
                const ts = document.createElement('div');
                ts.style.fontSize = '0.95rem';
                ts.style.color = '#888';
                ts.style.marginBottom = '18px';
                ts.textContent = new Date(timestamp).toLocaleString();
                content.appendChild(ts);
            }
            const para = document.createElement('div');
            para.textContent = text;
            content.appendChild(para);
            overlay.style.display = 'flex';
            setTimeout(() => { overlay.focus && overlay.focus(); }, 10);
        }
        document.getElementById('personal-popup-close').addEventListener('click', function() {
            document.getElementById('personal-popup-overlay').style.display = 'none';
        });
        document.getElementById('personal-popup-overlay').addEventListener('click', function(e) {
            if (e.target === this) this.style.display = 'none';
        });
        }

        function selectPersonalEntry(id) {
            const entry = personalHistory.find(e => e.id === id);
            if (!entry) return;
            document.getElementById('personal-detail-title').textContent = entry.title;
            document.getElementById('personal-detail-time').textContent = new Date(entry.timestamp).toLocaleString();
            document.getElementById('personal-detail-text').textContent = entry.text;
            // attach delete behavior
            document.getElementById('personal-delete').addEventListener('click', function() {
                if (!confirm('Delete this entry?')) return;
                personalHistory = personalHistory.filter(e => e.id !== id);
                savePersonalHistory();
                renderPersonalList();
                document.getElementById('personal-detail-title').textContent = '';
                document.getElementById('personal-detail-text').textContent = '';
                document.getElementById('personal-detail-time').textContent = '';
            });
        }

        // Try to generate a short title via DeepSeek; fallback to a truncated phrase
        async function generateTitleForSentence(sentence) {
            // If no API key, fallback
            if (DEEPSEEK_CONFIG.apiKey === 'YOUR_DEEPSEEK_API_KEY' || !DEEPSEEK_CONFIG.apiKey) {
                return fallbackTitle(sentence);
            }
            try {
                const response = await fetch(DEEPSEEK_CONFIG.apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${DEEPSEEK_CONFIG.apiKey}`
                    },
                    body: JSON.stringify({
                        model: DEEPSEEK_CONFIG.model,
                        messages: [{ role: 'user', content: `Create a short, descriptive title (3-6 words) for this sentence: "${sentence}". Return only the title.` }],
                        max_tokens: 30,
                        temperature: 0.2
                    })
                });
                if (!response.ok) throw new Error('Title API failed');
                const data = await response.json();
                const title = (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) ? data.choices[0].message.content.trim() : null;
                if (title) return title;
                return fallbackTitle(sentence);
            } catch (e) {
                return fallbackTitle(sentence);
            }
        }

        function fallbackTitle(sentence) {
            const words = sentence.replace(/[.?!]/g, '').split(/\s+/).filter(Boolean);
            const t = words.slice(0, 6).map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
            return t || 'Saved Entry';
        }

        // Save all revised sentences (prior to the command) as personal history entries
        async function saveAllRevisedSentencesAsPersonal() {
            if (!sentenceHistory || sentenceHistory.length === 0) {
                alert('No revised sentences available to save.');
                return;
            }
            // Make a shallow copy of sentences to process
            const toSave = sentenceHistory.slice();

            for (const s of toSave) {
                const text = (s && s.text) ? s.text : String(s);
                const title = await generateTitleForSentence(text);
                const entry = { id: String(Date.now()) + Math.random().toString(36).slice(2,8), title, text, timestamp: new Date().toISOString() };
                personalHistory.push(entry);
            }

            // Persist and render
            savePersonalHistory();
            renderPersonalList();

            // Remove loaded content from typingHistory (word-level history) by matching words
            try {
                toSave.forEach(s => {
                    const text = (s && s.text) ? s.text : String(s || '');
                    const words = text.replace(/[.?,!;:()"']/g, '').split(/\s+/).filter(Boolean);
                    words.forEach(w => {
                        const idx = typingHistory.findIndex(item => item && (item.text === w || (item.original && item.original === w)));
                        if (idx !== -1) {
                            typingHistory.splice(idx, 1);
                        }
                    });
                });
                saveHistory();
            } catch (e) {
                console.warn('Failed to remove words from typingHistory after moving sentences:', e);
            }

            // Clear sentenceHistory and update UI
            sentenceHistory = [];
            renderSentenceHistory();

            // Show sidebar and select the most recently added entry
            showPersonalSidebar();
            if (personalHistory.length) {
                const last = personalHistory[personalHistory.length - 1];
                selectPersonalEntry(last.id);
            }
        }

        // Keyboard handler: Cmd+Enter (Mac) or Ctrl+Enter (Windows/Linux) -> batch save
        let typingTimeout = null;
        const REMINDER_IDLE_MS = 3000;
        function showCourierReminder() {
            const el = document.getElementById('courier-reminder');
            if (!el) return;
            // Don't show if welcome overlay or auth modal is visible
            const welcome = document.getElementById('welcome-overlay');
            const auth = document.getElementById('auth-modal');
            if ((welcome && !welcome.classList.contains('hidden') && welcome.getAttribute('aria-hidden') !== 'true') ||
                (auth && auth.style.display !== 'none' && auth.style.display !== '')) {
                el.classList.remove('show');
                el.style.display = 'none';
                return;
            }
            el.style.display = 'block';
            el.classList.add('show');
        }
        function hideCourierReminder() {
            const el = document.getElementById('courier-reminder');
            if (!el) return;
            el.classList.remove('show');
        }
        function resetCourierReminderIdle() {
            hideCourierReminder();
            if (typingTimeout) clearTimeout(typingTimeout);
            typingTimeout = setTimeout(showCourierReminder, REMINDER_IDLE_MS);
        }

        // Show reminder after Ctrl+Enter restore
        document.addEventListener('keydown', function(e) {
            const isCmdEnter = (e.metaKey && e.key === 'Enter');
            const isCtrlEnter = (e.ctrlKey && e.key === 'Enter');
            if (isCmdEnter || isCtrlEnter) {
                e.preventDefault();
                saveAllRevisedSentencesAsPersonal();
                setTimeout(() => {
                    showCourierReminder();
                    if (typingTimeout) clearTimeout(typingTimeout);
                }, 350);
            }
        });

        // Sidebar show/hide interaction
        const sidebar = document.getElementById('personal-sidebar');
        const sidebarToggle = document.getElementById('personal-sidebar-toggle');
        let sidebarHideTimer = null;

        function showPersonalSidebar() {
            if (!sidebar) return;
            sidebar.classList.add('show');
            sidebar.setAttribute('aria-hidden', 'false');
            if (sidebarHideTimer) clearTimeout(sidebarHideTimer);
            // update chevron rotation state visually
            if (sidebarToggle) sidebarToggle.classList.add('open');
        }

        function hidePersonalSidebar() {
            if (!sidebar) return;
            sidebar.classList.remove('show');
            sidebar.setAttribute('aria-hidden', 'true');
            if (sidebarToggle) sidebarToggle.classList.remove('open');
        }

        // More sensitive show/hide behavior: show when mouse is near the left edge (sensor width)
        const SIDEBAR_SENSOR_WIDTH = 140; // px from left edge
        const SIDEBAR_HIDE_DELAY_MS = 180; // quick hide after leaving
        let lastMouseX = null;

        document.addEventListener('mousemove', function(evt) {
            try {
                lastMouseX = evt.clientX;
                if (evt.clientX <= SIDEBAR_SENSOR_WIDTH) {
                    // entered sensor area -> show immediately
                    showPersonalSidebar();
                    if (sidebarHideTimer) { clearTimeout(sidebarHideTimer); sidebarHideTimer = null; }
                    return;
                }

                // If cursor moved outside sensor and sidebar is open, start a short hide timer
                if (sidebar && sidebar.classList.contains('show')) {
                    if (sidebarHideTimer) clearTimeout(sidebarHideTimer);
                    sidebarHideTimer = setTimeout(() => {
                        // Only hide if mouse still outside sensor and not inside sidebar
                        try {
                            if ((lastMouseX || 0) > SIDEBAR_SENSOR_WIDTH) {
                                hidePersonalSidebar();
                            }
                        } catch (e) { hidePersonalSidebar(); }
                    }, SIDEBAR_HIDE_DELAY_MS);
                }
            } catch (e) { /* ignore in odd environments */ }
        });

        if (sidebarToggle) {
            // Hovering or clicking the small angle icon shows/hides the sidebar
            sidebarToggle.addEventListener('mouseenter', function() { showPersonalSidebar(); });
            sidebarToggle.addEventListener('click', function() {
                if (sidebar && sidebar.classList.contains('show')) hidePersonalSidebar(); else showPersonalSidebar();
            });
        }

        if (sidebar) {
            sidebar.addEventListener('mouseenter', function() { if (sidebarHideTimer) { clearTimeout(sidebarHideTimer); sidebarHideTimer = null; } });
            sidebar.addEventListener('mouseleave', function() { sidebarHideTimer = setTimeout(hidePersonalSidebar, SIDEBAR_HIDE_DELAY_MS); });
            document.getElementById('sidebar-close').addEventListener('click', hidePersonalSidebar);
        }

        // Load personal history initially
        loadPersonalHistory();
        renderPersonalList();
        
        // Add test data function for debugging
        window.addTestData = function() {
            const testEntry = {
                text: "This is a test sentence for debugging.",
                timestamp: new Date().toISOString(),
                wordCount: 7
            };
            
            // Add to local storage for testing
            const existingHistory = JSON.parse(localStorage.getItem('typingHistory') || '[]');
            existingHistory.push(testEntry);
            localStorage.setItem('typingHistory', JSON.stringify(existingHistory));
            
            console.log('Test data added to local storage');
            alert('Test data added! Try loading personal history now.');
        };
        
        // Debug function to check what's in localStorage
        window.debugStorage = function() {
            console.log('=== DEBUGGING STORAGE ===');
            console.log('Auth token:', localStorage.getItem('authToken'));
            console.log('User data:', localStorage.getItem('user'));
            console.log('Guest ID:', localStorage.getItem('guestId'));
            console.log('Typing history:', localStorage.getItem('typingHistory'));
            console.log('API_BASE:', API_BASE);
            console.log('========================');
        };
        
        // Clear all data and force fresh guest session
        window.clearAllAndRestart = function() {
            console.log('Clearing all data and restarting...');
            localStorage.clear();
            sessionStorage.clear();
            location.reload();
        };
        
        // Missing function
        function enableCourierReminderAfterWelcome() {
            // This function was referenced but not defined
            console.log('Courier reminder enabled after welcome');
        }

        // Authentication functions
        function initializeAuth() {
            console.log('Initializing authentication...');
            authToken = localStorage.getItem('authToken');
            guestId = localStorage.getItem('guestId');
            const userData = localStorage.getItem('user');
            
            console.log('Auth token:', authToken);
            console.log('Guest ID:', guestId);
            console.log('User data:', userData);
            
            // Check if we're running locally (file:// protocol)
            if (window.location.protocol === 'file:') {
                console.log('Running in local file mode');
                // For local testing, always show auth modal first time
                if (!authToken && !guestId) {
                    console.log('No authentication found, showing modal');
                    showAuthModal();
                    return;
                }
            }
            
            if (authToken && userData) {
                isAuthenticated = true;
                currentUser = JSON.parse(userData);
                updateAuthUI();
                hideAuthModal();
                console.log('User authenticated');
            } else if (guestId) {
                isGuest = true;
                updateAuthUI();
                hideAuthModal();
                console.log('Guest session active');
            } else {
                // No authentication - show auth modal
                console.log('No authentication found, showing modal');
                showAuthModal();
                return;
            }
            
            // Load user data
            loadHistory();
            loadUserSettings();
        }
        
        function showAuthModal() {
            const authModal = document.getElementById('auth-modal');
            if (authModal) {
                authModal.style.display = 'flex';
                console.log('Auth modal shown');
            } else {
                console.log('Auth modal not found');
            }
        }
        
        function hideAuthModal() {
            const authModal = document.getElementById('auth-modal');
            if (authModal) {
                authModal.style.display = 'none';
            }
            // After the auth modal is closed, show the welcome overlay (unless already dismissed)
            try {
                const dismissed = localStorage.getItem('calm_welcome_dismissed');
                if (!dismissed) {
                    // small delay so the UI settles after modal hide
                    setTimeout(() => { showWelcomeOverlay(); }, 220);
                } else {
                    setTimeout(enableCourierReminderAfterWelcome, 400);
                }
            } catch (e) { setTimeout(enableCourierReminderAfterWelcome, 400); }
        }
        
        // Create guest session automatically
        async function createGuestSession() {
            try {
                // Check if we're running on a server (has API_BASE)
                if (window.location.protocol === 'file:') {
                    // Running locally without server - use localStorage only
                    isGuest = true;
                    guestId = 'local-guest-' + Date.now();
                    localStorage.setItem('guestId', guestId);
                    updateAuthUI();
                    loadHistory();
                    loadUserSettings();
                    return;
                }
                
                // Running on server - create proper guest session
                console.log('Creating guest session, API_BASE:', API_BASE);
                const response = await fetch(`${API_BASE}/api/auth/guest`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('Guest session response status:', response.status);
                console.log('Guest session response ok:', response.ok);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Guest session created:', result);
                    guestId = result.guestId;
                    localStorage.setItem('guestId', guestId);
                    isGuest = true;
                    updateAuthUI();
                    loadHistory();
                    loadUserSettings();
                } else {
                    console.log('Guest session creation failed, falling back to local');
                    // Fallback to local guest session
                    isGuest = true;
                    guestId = 'local-guest-' + Date.now();
                    localStorage.setItem('guestId', guestId);
                    updateAuthUI();
                    loadHistory();
                    loadUserSettings();
                }
            } catch (error) {
                // Fallback to local guest session
                isGuest = true;
                guestId = 'local-guest-' + Date.now();
                localStorage.setItem('guestId', guestId);
                updateAuthUI();
                loadHistory();
                loadUserSettings();
            }
        }
        
        function updateAuthUI() {
            // Update logout button visibility
            const logoutBtn = document.getElementById('logout-btn');
            if (logoutBtn) {
                if (isAuthenticated) {
                    logoutBtn.style.display = 'block';
                } else {
                    logoutBtn.style.display = 'none';
                }
            }
            
            // Add auth status to controls
            const controlsContent = document.getElementById('controls-content');
            if (controlsContent && !document.getElementById('auth-status')) {
                const authStatus = document.createElement('div');
                authStatus.id = 'auth-status';
                authStatus.style.marginTop = '20px';
                authStatus.style.padding = '10px';
                authStatus.style.background = 'rgba(102, 126, 234, 0.1)';
                authStatus.style.borderRadius = '8px';
                authStatus.style.fontSize = '12px';
                
                if (isAuthenticated) {
                    authStatus.innerHTML = `
                        <div style="color: #667eea; font-weight: 500;">Signed in as ${currentUser.username}</div>
                        <button id="auth-logout-btn" style="margin-top: 5px; padding: 4px 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Sign Out</button>
                    `;
                    
                    // Add event listener for the logout button
                    const authLogoutBtn = document.getElementById('auth-logout-btn');
                    if (authLogoutBtn) {
                        authLogoutBtn.addEventListener('click', function() {
                            logout();
                        });
                    }
                } else if (isGuest) {
                    authStatus.innerHTML = `
                        <div style="color: #999;">Guest Session</div>
                        <button id="auth-signin-btn" style="margin-top: 5px; padding: 4px 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Sign In</button>
                    `;
                    
                    // Add event listener for the sign in button
                    const authSigninBtn = document.getElementById('auth-signin-btn');
                    if (authSigninBtn) {
                        authSigninBtn.addEventListener('click', function() {
                            switchToAuth();
                        });
                    }
                }
                
                controlsContent.appendChild(authStatus);
            }
        }
        
        function logout() {
            localStorage.removeItem('authToken');
            localStorage.removeItem('user');
            localStorage.removeItem('guestId');
            isAuthenticated = false;
            currentUser = null;
            authToken = null;
            isGuest = false;
            guestId = null;
            updateAuthUI();
            showAuthModal();
        }
        
        function switchToAuth() {
            showAuthModal();
        }
        
        // Function to clear all authentication data (for testing)
        function clearAuthData() {
            localStorage.removeItem('authToken');
            localStorage.removeItem('user');
            localStorage.removeItem('guestId');
            localStorage.removeItem('typingHistory');
            localStorage.removeItem('userSettings');
            console.log('All authentication data cleared');
            location.reload();
        }
        
        // Authentication form handlers
        function switchAuthTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.auth-tabs .tab').forEach(t => t.classList.remove('active'));
            document.getElementById(tab + '-tab').classList.add('active');
            
            // Update forms
            document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
            document.getElementById(tab + '-form').classList.add('active');
            
            // Clear messages
            clearAuthMessages();
        }
        
        function clearAuthMessages() {
            const messages = document.querySelectorAll('.error-message, .success-message');
            messages.forEach(msg => msg.remove());
        }
        
        function showAuthError(message) {
            clearAuthMessages();
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            document.querySelector('.auth-container').insertBefore(errorDiv, document.querySelector('.auth-tabs'));
        }
        
        function showAuthSuccess(message) {
            clearAuthMessages();
            const successDiv = document.createElement('div');
            successDiv.className = 'success-message';
            successDiv.textContent = message;
            document.querySelector('.auth-container').insertBefore(successDiv, document.querySelector('.auth-tabs'));
        }
        
        function setAuthLoading(buttonId, textId, loadingId, isLoading) {
            const button = document.getElementById(buttonId);
            const text = document.getElementById(textId);
            const loading = document.getElementById(loadingId);
            
            button.disabled = isLoading;
            text.style.display = isLoading ? 'none' : 'inline';
            loading.style.display = isLoading ? 'inline-block' : 'none';
        }
        
        async function handleLogin(event) {
            event.preventDefault();
            setAuthLoading('login-btn', 'login-text', 'login-loading', true);
            
            const formData = new FormData(event.target);
            const data = {
                username: formData.get('username'),
                password: formData.get('password')
            };
            
            // Check if we're running locally (file:// protocol only)
            const isLocalMode = window.location.protocol === 'file:';
            
            if (isLocalMode) {
                // Local mode - simulate login
                showAuthError('Server not available in local mode. Please use "Continue as Guest" or deploy to test authentication.');
                setAuthLoading('login-btn', 'login-text', 'login-loading', false);
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/auth/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    // Store token and user data
                    localStorage.setItem('authToken', result.token);
                    localStorage.setItem('user', JSON.stringify(result.user));
                    showAuthSuccess('Login successful! Redirecting...');
                    setTimeout(() => {
                        isAuthenticated = true;
                        currentUser = result.user;
                        authToken = result.token;
                        updateAuthUI();
                        hideAuthModal();
                        loadHistory();
                        loadUserSettings();
                    }, 1000);
                } else {
                    showAuthError(result.error || 'Login failed');
                }
            } catch (error) {
                showAuthError('Network error. Please try again.');
            } finally {
                setAuthLoading('login-btn', 'login-text', 'login-loading', false);
            }
        }
        
        async function handleRegister(event) {
            event.preventDefault();
            setAuthLoading('register-btn', 'register-text', 'register-loading', true);
            
            const formData = new FormData(event.target);
            const data = {
                username: formData.get('username'),
                email: formData.get('email'),
                password: formData.get('password')
            };
            
            // Check if we're running locally (file:// protocol only)
            const isLocalMode = window.location.protocol === 'file:';
            
            if (isLocalMode) {
                // Local mode - simulate registration
                showAuthError('Server not available in local mode. Please use "Continue as Guest" or deploy to test authentication.');
                setAuthLoading('register-btn', 'register-text', 'register-loading', false);
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/auth/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    // Store token and user data
                    localStorage.setItem('authToken', result.token);
                    localStorage.setItem('user', JSON.stringify(result.user));
                    showAuthSuccess('Registration successful! Redirecting...');
                    setTimeout(() => {
                        isAuthenticated = true;
                        currentUser = result.user;
                        authToken = result.token;
                        updateAuthUI();
                        hideAuthModal();
                        loadHistory();
                        loadUserSettings();
                    }, 1000);
                } else {
                    showAuthError(result.error || 'Registration failed');
                }
            } catch (error) {
                showAuthError('Network error. Please try again.');
            } finally {
                setAuthLoading('register-btn', 'register-text', 'register-loading', false);
            }
        }
        
        async function handleGuestAccess() {
            console.log('Handling guest access...');
            console.log('Protocol:', window.location.protocol);
            console.log('Hostname:', window.location.hostname);
            
            // Check if we're running locally (file:// protocol only)
            const isLocalMode = window.location.protocol === 'file:';
            
            if (isLocalMode) {
                console.log('Local mode detected, creating local guest session');
                // Local mode - create guest session locally
                const localGuestId = 'local-guest-' + Date.now();
                localStorage.setItem('guestId', localGuestId);
                localStorage.removeItem('authToken');
                localStorage.removeItem('user');
                showAuthSuccess('Guest session created! Redirecting...');
                setTimeout(() => {
                    isGuest = true;
                    guestId = localGuestId;
                    updateAuthUI();
                    hideAuthModal();
                    loadHistory();
                    loadUserSettings();
                }, 1000);
                return;
            }
            
            console.log('Server mode detected, connecting to server');
            try {
                const response = await fetch(`${API_BASE}/api/auth/guest`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    // Store guest session
                    localStorage.setItem('guestId', result.guestId);
                    localStorage.removeItem('authToken');
                    localStorage.removeItem('user');
                    showAuthSuccess('Guest session created! Redirecting...');
                    setTimeout(() => {
                        isGuest = true;
                        guestId = result.guestId;
                        updateAuthUI();
                        hideAuthModal();
                        loadHistory();
                        loadUserSettings();
                    }, 1000);
                } else {
                    showAuthError(result.error || 'Failed to create guest session');
                }
            } catch (error) {
                showAuthError('Network error. Please try again.');
            }
        }
        
        async function loadUserSettings() {
            // Check if we're running on a server
            if (window.location.protocol === 'file:') {
                // Local file mode - use localStorage only
                const saved = localStorage.getItem('userSettings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        applySettings(settings);
                    } catch (e) {
                        console.log('Failed to parse saved settings');
                    }
                }
                return;
            }
            
            if (isAuthenticated) {
                try {
                    const response = await fetch(`${API_BASE}/user/data/settings`, {
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });
                    if (response.ok) {
                        const result = await response.json();
                        if (result.data) {
                            applySettings(result.data);
                        }
                    }
                } catch (error) {
                    console.log('Failed to load settings from server');
                }
            } else if (isGuest) {
                try {
                    const response = await fetch(`${API_BASE}/api/guest/data/settings`, {
                        headers: {
                            'x-guest-id': guestId
                        }
                    });
                    if (response.ok) {
                        const result = await response.json();
                        if (result.data) {
                            applySettings(result.data);
                        }
                    }
                } catch (error) {
                    console.log('Failed to load guest settings');
                }
            }
        }
        
        function applySettings(settings) {
            if (settings.fontSize) fontSize = settings.fontSize;
            if (settings.textColor) textColor = settings.textColor;
            if (settings.fontFamily) customFontFamily = settings.fontFamily;
            if (settings.volume) currentVolume = settings.volume;
            
            // Update UI elements
            if (document.getElementById('size-slider')) {
                document.getElementById('size-slider').value = fontSize;
                document.getElementById('size-value').textContent = fontSize + 'px';
            }
            if (document.getElementById('color-picker')) {
                document.getElementById('color-picker').value = textColor;
            }
            if (document.getElementById('font-select')) {
                document.getElementById('font-select').value = customFontFamily;
            }
            if (document.getElementById('volume-slider-vertical')) {
                document.getElementById('volume-slider-vertical').value = currentVolume * 100;
                document.getElementById('volume-value').textContent = Math.round(currentVolume * 100) + '%';
            }
        }
        
        async function saveUserSettings() {
            const settings = {
                fontSize,
                textColor,
                fontFamily: customFontFamily,
                volume: currentVolume
            };
            
            // Check if we're running on a server
            if (window.location.protocol === 'file:') {
                // Local file mode - use localStorage only
                localStorage.setItem('userSettings', JSON.stringify(settings));
                return;
            }
            
            if (isAuthenticated) {
                try {
                    await fetch(`${API_BASE}/user/data/settings`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify(settings)
                    });
                } catch (error) {
                    console.log('Failed to save settings to server');
                }
            } else if (isGuest) {
                try {
                    await fetch(`${API_BASE}/api/guest/data/settings`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-guest-id': guestId
                        },
                        body: JSON.stringify(settings)
                    });
                } catch (error) {
                    console.log('Failed to save guest settings');
                }
            }
        }
        
        // Initialize authentication on startup
        initializeAuth();
        
        // Add event listeners for authentication modal
        document.addEventListener('DOMContentLoaded', function() {
            // Tab switching
            const loginTab = document.getElementById('login-tab');
            const registerTab = document.getElementById('register-tab');
            
            if (loginTab) {
                loginTab.addEventListener('click', function() {
                    switchAuthTab('login');
                });
            }
            
            if (registerTab) {
                registerTab.addEventListener('click', function() {
                    switchAuthTab('register');
                });
            }
            
            // Form submissions
            const loginForm = document.getElementById('login-form-element');
            const registerForm = document.getElementById('register-form-element');
            const guestButton = document.getElementById('guest-button');
            
            if (loginForm) {
                loginForm.addEventListener('submit', function(event) {
                    handleLogin(event);
                });
            }
            
            if (registerForm) {
                registerForm.addEventListener('submit', function(event) {
                    handleRegister(event);
                });
            }
            
            if (guestButton) {
                guestButton.addEventListener('click', function() {
                    handleGuestAccess();
                });
            }
        });
        
        // DeepSeek API functions
        async function autoCorrectWord(word) {
            console.log('Auto-correcting word:', word);
            
            // Check if API key is set
            if (DEEPSEEK_CONFIG.apiKey === 'YOUR_DEEPSEEK_API_KEY' || !DEEPSEEK_CONFIG.apiKey) {
                console.log('DeepSeek API key not configured, using local correction');
                return getLocalCorrection(word);
            }
            
            try {
                console.log('Calling DeepSeek API for correction...');
                const correctedWord = await callDeepSeekCorrection(word);
                console.log('DeepSeek correction:', correctedWord);
                return correctedWord;
            } catch (error) {
                console.log('DeepSeek API error:', error);
                console.log('Falling back to local correction');
                return getLocalCorrection(word);
            }
        }
        
        async function callDeepSeekCorrection(word) {
            const response = await fetch(DEEPSEEK_CONFIG.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${DEEPSEEK_CONFIG.apiKey}`
                },
                body: JSON.stringify({
                    model: DEEPSEEK_CONFIG.model,
                    messages: [
                        {
                            role: 'user',
                            content: `Analyze this word: "${word}". 
                            1. If it's a curse word, profanity, or inappropriate language, replace it with a cute kaomoji (like (╯°□°）╯︵ ┻━┻ or (╯︵╰,) or ٩(◕‿◕)۶)
                            2. If it's a misspelled normal word, correct it to proper English
                            3. If it's already correct, return it unchanged
                            Return only the result, nothing else.`
                        }
                    ],
                    max_tokens: 30,
                    temperature: 0.3
                })
            });
            
            if (!response.ok) {
                throw new Error(`API request failed: ${response.status}`);
            }
            
            const data = await response.json();
            const correctedWord = data.choices[0].message.content.trim();
            
            return correctedWord || word; // Return original if correction fails
        }
        
        function getKaomojiForCurseWord(word) {
            // Curse word detection and kaomoji replacement
            const curseWords = {
                'shit': '(╯°□°）╯︵ ┻━┻',
                'fuck': '(╯︵╰,)',
                'damn': '٩(◕‿◕)۶',
                'hell': '(╯°□°）╯︵ ┻━┻',
                'bitch': '(╯︵╰,)',
                'ass': '(╯°□°）╯︵ ┻━┻',
                'crap': '(╯︵╰,)',
                'piss': '٩(◕‿◕)۶',
                'dick': '(╯°□°）╯︵ ┻━┻',
                'cock': '(╯︵╰,)',
                'pussy': '٩(◕‿◕)۶',
                'fag': '(╯°□°）╯︵ ┻━┻',
                'gay': '(╯︵╰,)',
                'retard': '٩(◕‿◕)۶',
                'stupid': '(╯°□°）╯︵ ┻━┻',
                'idiot': '(╯︵╰,)',
                'moron': '٩(◕‿◕)۶',
                'bastard': '(╯°□°）╯︵ ┻━┻',
                'whore': '(╯︵╰,)',
                'slut': '٩(◕‿◕)۶',
                'bitch': '(╯°□°）╯︵ ┻━┻',
                'fucking': '(╯︵╰,)',
                'shitty': '٩(◕‿◕)۶',
                'damned': '(╯°□°）╯︵ ┻━┻',
                'hellish': '(╯︵╰,)',
                'cursed': '٩(◕‿◕)۶',
                'fucked': '(╯°□°）╯︵ ┻━┻',
                'shitted': '(╯︵╰,)',
                'damning': '٩(◕‿◕)۶'
            };
            
            const lowerWord = word.toLowerCase();
            return curseWords[lowerWord] || null;
        }
        
        function getLocalCorrection(word) {
            // First check for curse words
            const kaomoji = getKaomojiForCurseWord(word);
            if (kaomoji) {
                console.log('Local curse word detected, converting to kaomoji:', word, '->', kaomoji);
                return kaomoji;
            }
            
            // Check if word is already correct (common words)
            const commonWords = [
                'the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'had', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has', 'him', 'his', 'how', 'its', 'may', 'new', 'now', 'old', 'see', 'two', 'way', 'who', 'boy', 'did', 'man', 'men', 'put', 'say', 'she', 'too', 'use', 'want', 'been', 'call', 'come', 'does', 'each', 'find', 'give', 'good', 'have', 'here', 'just', 'know', 'like', 'long', 'look', 'make', 'many', 'more', 'most', 'much', 'name', 'need', 'only', 'over', 'part', 'place', 'right', 'said', 'same', 'seem', 'should', 'small', 'still', 'such', 'take', 'than', 'them', 'there', 'these', 'they', 'this', 'time', 'very', 'well', 'were', 'what', 'when', 'where', 'which', 'while', 'will', 'with', 'work', 'would', 'write', 'your', 'about', 'after', 'again', 'before', 'below', 'between', 'during', 'except', 'inside', 'outside', 'through', 'under', 'within', 'without'
            ];
            
            if (commonWords.includes(word.toLowerCase())) {
                console.log('Word is already correct:', word);
                return word;
            }
            
            // Simple local correction using common misspellings
            const corrections = {
                // Common misspellings
                'teh': 'the',
                'adn': 'and',
                'taht': 'that',
                'recieve': 'receive',
                'seperate': 'separate',
                'occured': 'occurred',
                'definately': 'definitely',
                'accomodate': 'accommodate',
                'begining': 'beginning',
                'beleive': 'believe',
                'calender': 'calendar',
                'cemetary': 'cemetery',
                'concious': 'conscious',
                'existance': 'existence',
                'goverment': 'government',
                'independant': 'independent',
                'occassion': 'occasion',
                'priviledge': 'privilege',
                'rythm': 'rhythm',
                'thier': 'their',
                'untill': 'until',
                'wich': 'which',
                'writting': 'writing',
                'youself': 'yourself',
                'acheive': 'achieve',
                'becuase': 'because',
                'comming': 'coming',
                'differnt': 'different',
                'enviroment': 'environment',
                'finnally': 'finally',
                'frend': 'friend',
                'grate': 'great',
                'happend': 'happened',
                'immediatly': 'immediately',
                'knowlege': 'knowledge',
                'lenght': 'length',
                'mispell': 'misspell',
                'neccessary': 'necessary',
                'occured': 'occurred',
                'publically': 'publicly',
                'recieve': 'receive',
                'seperate': 'separate',
                'succesful': 'successful',
                'thier': 'their',
                'untill': 'until',
                'wich': 'which',
                'writting': 'writing'
            };
            
            const corrected = corrections[word.toLowerCase()] || word;
            console.log('Local correction:', word, '->', corrected);
            return corrected;
        }
        
        // Cycle through backgrounds
        function cycleBackground() {
            // Remove active class from current background
            if (backgrounds[currentBackground].element) {
                backgrounds[currentBackground].element.classList.remove('active');
            }
            
            // Move to next background
            currentBackground = (currentBackground + 1) % backgrounds.length;
            
            // Add active class to new background
            if (backgrounds[currentBackground].element) {
                backgrounds[currentBackground].element.classList.add('active');
            }
            
            // Update button icon
            backgroundToggle.innerHTML = backgrounds[currentBackground].icon;
        }
        
        // Toggle background on click
        backgroundToggle.addEventListener('click', function() {
            // Add rotation animation
            backgroundToggle.classList.add('rotating');
            setTimeout(() => {
                backgroundToggle.classList.remove('rotating');
            }, 500);
            
            cycleBackground_withAudio();
        });
        
        // Volume control toggle
        volumeControl.addEventListener('click', function(e) {
            e.stopPropagation();
            volumeSliderContainer.classList.toggle('show');
        });

        // Fish toggle: enable/disable FishFX and update UI
        let fishEnabled = true;
        function updateFishToggleUI() {
            if (!fishToggle) return;
            fishToggle.classList.toggle('active', fishEnabled);
            fishToggle.setAttribute('aria-pressed', fishEnabled ? 'true' : 'false');
            fishToggle.title = fishEnabled ? 'Disable Fish' : 'Enable Fish';
        }

        if (fishToggle) {
            fishToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                fishEnabled = !fishEnabled;
                if (window.FishFX) {
                    if (fishEnabled) window.FishFX.enable(); else window.FishFX.disable();
                }
                updateFishToggleUI();
            });
        }

        // Initialize fish toggle UI based on default
        updateFishToggleUI();
        
        // Audio system: per-background tracks
        let audioTracks = {}; // persistent tracks saved in localStorage (only remote URLs or path strings)
        const uploadedTracks = {}; // session-only object URLs for uploaded local files

        function loadAudioTracks() {
            try {
                const raw = localStorage.getItem('bgAudioTracks');
                audioTracks = raw ? JSON.parse(raw) : {};
            } catch (e) {
                audioTracks = {};
            }
        }

        function saveAudioTracks() {
            try {
                localStorage.setItem('bgAudioTracks', JSON.stringify(audioTracks));
            } catch (e) {
                console.warn('Failed to persist audio tracks', e);
            }
        }

        function getTrackForBackground(name) {
            if (uploadedTracks[name]) return uploadedTracks[name];
            return audioTracks[name] || null;
        }

        function applyBackgroundAudio() {
            const bg = backgrounds[currentBackground].name;
            const track = getTrackForBackground(bg);
            if (track && track.src) {
                if (bgAudio.src !== track.src) {
                    bgAudio.src = track.src;
                }
                bgAudio.volume = currentVolume;
                bgAudio.play().catch(()=>{
                    // Autoplay may be blocked; update UI accordingly
                    audioControl.classList.remove('active');
                });
                audioControl.classList.add('active');
                audioControl.title = 'Pause Music';
            } else {
                bgAudio.pause();
                bgAudio.removeAttribute('src');
                bgAudio.load();
                audioControl.classList.remove('active');
                audioControl.title = 'Play Music';
            }
        }

        // UI elements for audio mapping
        const audioBgSelect = document.getElementById('audio-bg-select');
        const audioUploadFile = document.getElementById('audio-upload-file');
        const audioUploadUrl = document.getElementById('audio-upload-url');
        const audioAssignBtn = document.getElementById('audio-assign-btn');
        const audioRemoveBtn = document.getElementById('audio-remove-btn');
        const audioCurrentLabel = document.getElementById('audio-current-label');

        function updateAudioCurrentLabel() {
            const bg = backgrounds[currentBackground].name;
            const t = getTrackForBackground(bg);
            if (t && t.label) {
                audioCurrentLabel.textContent = `Assigned: ${t.label}`;
            } else if (t && t.src) {
                audioCurrentLabel.textContent = `Assigned: ${t.src}`;
            } else {
                audioCurrentLabel.textContent = 'No music assigned for current background.';
            }
        }

        // Assign button handler
        if (audioAssignBtn) {
            audioAssignBtn.addEventListener('click', function() {
                const bg = audioBgSelect.value || 'none';
                // prefer file upload
                const file = audioUploadFile.files && audioUploadFile.files[0];
                const url = (audioUploadUrl.value || '').trim();
                if (file) {
                    const obj = URL.createObjectURL(file);
                    // revoke previous if existed
                    if (uploadedTracks[bg] && uploadedTracks[bg].isObject) {
                        try { URL.revokeObjectURL(uploadedTracks[bg].src); } catch(e){}
                    }
                    uploadedTracks[bg] = { src: obj, label: file.name, isObject: true };
                    // If assigned to currently active background, apply immediately
                    if (backgrounds[currentBackground].name === bg) applyBackgroundAudio();
                    updateAudioCurrentLabel();
                } else if (url) {
                    // simple validation
                    try {
                        const parsed = new URL(url);
                        audioTracks[bg] = { src: parsed.href, label: parsed.href };
                        saveAudioTracks();
                        if (backgrounds[currentBackground].name === bg) applyBackgroundAudio();
                        updateAudioCurrentLabel();
                    } catch (e) {
                        alert('Please enter a valid URL (must start with http/https).');
                    }
                } else {
                    alert('Please choose an audio file or enter a remote URL to assign.');
                }
            });
        }

        // Remove mapping
        if (audioRemoveBtn) {
            audioRemoveBtn.addEventListener('click', function() {
                const bg = audioBgSelect.value || 'none';
                if (uploadedTracks[bg] && uploadedTracks[bg].isObject) {
                    try { URL.revokeObjectURL(uploadedTracks[bg].src); } catch(e){}
                    delete uploadedTracks[bg];
                }
                if (audioTracks[bg]) {
                    delete audioTracks[bg];
                    saveAudioTracks();
                }
                if (backgrounds[currentBackground].name === bg) applyBackgroundAudio();
                updateAudioCurrentLabel();
            });
        }

        // When background changes update the UI label
        const _origApplyBg = applyBackgroundAudio;
        function applyBackgroundAudio_andUpdateUI() {
            _origApplyBg();
            updateAudioCurrentLabel();
        }
        // Replace calls to applyBackgroundAudio where needed
        // Initialize audio tracks and UI
        loadAudioTracks();

        // Provide sensible default tracks from the local `Audios/` folder if the user hasn't assigned any
        (function ensureDefaultLocalTracks(){
            const defaults = {
                forest: {
                    src: 'Audios/15-minutes-of-rain-sound-for-relaxation-and-sleep-study-312863.mp3',
                    label: 'Rain - 15 minutes'
                },
                ocean: {
                    src: 'Audios/ocean-waves-376898.mp3',
                    label: 'Ocean Waves'
                },
                mountain: {
                    src: 'Audios/the-sound-of-a-mountain-stream-_nature-sound-201930.mp3',
                    label: 'Mountain Stream'
                }
            };

            let changed = false;
            for (const k of Object.keys(defaults)) {
                // don't overwrite any user-mapped remote URL or uploaded session file
                if (!audioTracks[k] && !uploadedTracks[k]) {
                    audioTracks[k] = defaults[k];
                    changed = true;
                }
            }
            if (changed) saveAudioTracks();
        })();

        updateAudioCurrentLabel();
        // Ensure audio follows initial background (none)
        applyBackgroundAudio();

        // Wire audio control button
        if (audioControl) {
            audioControl.addEventListener('click', function(e) {
                e.stopPropagation();
                if (!bgAudio.src) {
                    // try to apply current background's audio
                    applyBackgroundAudio();
                    return;
                }
                if (bgAudio.paused) {
                    bgAudio.play().then(()=>{
                        audioControl.classList.add('active');
                        audioControl.title = 'Pause Music';
                    }).catch(()=>{});
                } else {
                    bgAudio.pause();
                    audioControl.classList.remove('active');
                    audioControl.title = 'Play Music';
                }
            });
        }

        // Volume should control audio element too
        volumeSlider.addEventListener('input', function() {
            currentVolume = this.value / 100;
            volumeValue.textContent = this.value + '%';
            if (bgAudio) bgAudio.volume = currentVolume;
            saveUserSettings();
        });

        // Update cycleBackground to also change audio
        const _origCycleBackground = cycleBackground;
        function cycleBackground_withAudio() {
            _origCycleBackground();
            applyBackgroundAudio();
        }
        // Replace listener used earlier by direct function reference; backgroundToggle uses cycleBackground call, so update that call site instead
        
        // Close volume slider when clicking outside
        document.addEventListener('click', function(e) {
            if (!volumeControl.contains(e.target) && !volumeSliderContainer.contains(e.target)) {
                volumeSliderContainer.classList.remove('show');
            }
        });
        
        // Handle volume change
        volumeSlider.addEventListener('input', function() {
            currentVolume = this.value / 100;
            volumeValue.textContent = this.value + '%';
        });
        
        // Toggle controls panel
        toggleBtn.addEventListener('click', function() {
            controls.classList.toggle('collapsed');
            toggleBtn.textContent = controls.classList.contains('collapsed') ? '☰' : '✕';
        });
        
        // Handle color change
        colorPicker.addEventListener('input', function() {
            textColor = this.value;
            saveUserSettings();
        });
        
        // Handle size change
        sizeSlider.addEventListener('input', function() {
            fontSize = parseInt(this.value);
            sizeValue.textContent = fontSize + 'px';
            saveUserSettings();
        });
        
        // Handle font selection
        fontSelect.addEventListener('change', function() {
            customFontFamily = this.value;
            saveUserSettings();
        });
        
        // Handle font upload
        fontUpload.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const fontName = 'CustomFont_' + Date.now();
                    const fontFace = new FontFace(fontName, event.target.result);
                    
                    fontFace.load().then(function(loadedFace) {
                        document.fonts.add(loadedFace);
                        customFontFamily = fontName;
                        
                        // Update select to show custom font is active
                        fontSelect.value = '';
                        console.log('Font loaded:', fontName);
                    }).catch(function(error) {
                        console.error('Font loading failed:', error);
                        alert('Failed to load font. Please try another file.');
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });
        
        // Helper function to convert hex to rgba
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Handle typing
        document.addEventListener('keypress', function(e) {
            if (e.target.tagName === 'INPUT') return;
            const char = e.key;
            if (char.length !== 1) return;
            
            // Reset on space (don't save individual words)
            if (char === ' ') {
                if (currentWord.length > 0) {
                    currentWord = '';
                }
                currentSentence += ' ';
                charPosition = 0;
                return;
            }
            
            // Add character to current word and sentence
            currentWord += char;
            currentSentence += char;
            
            clearTimeout(resetTimeout);
            createFloatingText(char, charPosition);
            charPosition++;

            // If period, treat as end of sentence
            if (char === '.') {
                // Save complete sentence for revision
                const sentenceToCheck = currentSentence.trim();
                if (sentenceToCheck.length > 0) {
                    addSentenceToHistory(sentenceToCheck);
                }
                currentWord = '';
                currentSentence = '';
                charPosition = 0;
                return;
            }
            
            // Clear any existing timeout
            if (resetTimeout) {
                clearTimeout(resetTimeout);
            }
        });
        
        // Reset position on Enter and save word/sentence
        document.addEventListener('keydown', function(e) {
            // Tab to toggle history
            if (e.key === 'Tab') {
                e.preventDefault();
                toggleHistory();
                return;
            }
            
            if (e.key === 'Enter') {
                // Only save complete sentences, not individual words
                if (currentSentence.trim().length > 0) {
                    addSentenceToHistory(currentSentence.trim());
                    currentSentence = '';
                }
                currentWord = '';
                charPosition = 0;
            }
        });
        
        function createFloatingText(text, position) {
            const charElement = document.createElement('div');
            charElement.className = 'char';
            charElement.textContent = text;
            charElement.style.fontFamily = customFontFamily;
            charElement.style.fontSize = fontSize + 'px';
            
            // Position characters in a line with spacing
            const charWidth = 90; // spacing between characters
            const startX = -((charPosition + 1) * charWidth / 2); // center the line
            const offsetX = startX + (position * charWidth);
            charElement.style.left = `calc(50% + ${offsetX}px)`;
            charElement.style.top = '50%';
            
            // Apply color and matching glow effect
            charElement.style.color = textColor;
            charElement.style.textShadow = `0 0 20px ${hexToRgba(textColor, 0.5)}`;
            
            container.appendChild(charElement);
            activeChars++;
            
            // Remove after animation (linger a bit longer for calmer effect)
            setTimeout(() => {
                charElement.remove();
                activeChars--;

                // Reset position when all chars are cleared
                if (activeChars === 0) {
                    charPosition = 0;
                }
            }, 2400);
        }
        
        // Hide instructions after first keypress
        let firstKey = true;
        document.addEventListener('keypress', function() {
            if (firstKey) {
                document.getElementById('instructions').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('instructions').style.display = 'none';
                }, 500);
                firstKey = false;
            }
            hideCourierReminder();
            if (typingTimeout) clearTimeout(typingTimeout);
        });

        // Show reminder after idle, and on page load
        window.addEventListener('DOMContentLoaded', function() {
            setTimeout(showCourierReminder, 600);
            document.addEventListener('mousemove', resetCourierReminderIdle, { once: true });
        });

        // Hide reminder and reset idle timer on any typing
        document.addEventListener('keydown', function(e) {
            // Ignore modifier keys
            if (e.key.length === 1 || e.key === 'Backspace' || e.key === 'Enter' || e.key === ' ') {
                hideCourierReminder();
                resetCourierReminderIdle();
            }
        });
        
        // FishFX Module - Fish Animation System
        (function (global) {
            const cfg = {
                minIntervalMs: 90,
                maxConcurrency: 20,
                fishEmojis: ['🐠', '🐡', '🐟'],
                sharkEmoji: '🦈',
                useArcProb: 0,
                attachListener: false
            };

            const state = {
                layer: null,
                lastTs: 0,
                enabled: true
            };

            function init() {
                state.layer = document.getElementById('fish-layer');
                if (!state.layer) {
                    console.warn('[FishFX] 未找到 #fish-layer，已自动创建。');
                    const el = document.createElement('div');
                    el.id = 'fish-layer';
                    el.setAttribute('aria-hidden', 'true');
                    document.body.appendChild(el);
                    state.layer = el;
                }
            }

            function now() { return performance.now(); }

            function getKeyPos(key) {
                const rows = {
                    num: ['`','1','2','3','4','5','6','7','8','9','0','-','='],
                    q  : ['q','w','e','r','t','y','u','i','o','p','[',']'],
                    a  : ['a','s','d','f','g','h','j','k','l',';'],
                    z  : ['z','x','c','v','b','n','m',',','.','/']
                };
                const rowYvh = { num:85, q:88, a:91, z:94 };
                const rowShift = { num:0.0, q:0.5, a:1.0, z:1.5 };

                key = String(key || '').toLowerCase();
                for (const r of ['num','q','a','z']) {
                    const arr = rows[r];
                    const idx = arr.indexOf(key);
                    if (idx !== -1) {
                        const vw = innerWidth, vh = innerHeight;
                        const colW = vw / (arr.length + 2);
                        const colIndex = idx + 1 + rowShift[r];
                        const x = colW * (colIndex + 0.5) + (Math.random() - 0.5) * 20;
                        const y = vh * (rowYvh[r] / 100) + (Math.random() - 0.5) * 10;
                        return { x, y };
                    }
                }
                if (key === ' ') return { x: innerWidth * 0.5, y: innerHeight * 0.95 };
                return null;
            }

            function getRandomPos() {
                const marginX = Math.max(20, innerWidth * 0.05);
                const marginY = Math.max(20, innerHeight * 0.05);
                const x = marginX + Math.random() * (innerWidth - marginX * 2);
                const y = marginY + Math.random() * (innerHeight - marginY * 2);
                return { x, y };
            }
            
            function spawnAt(pos, { emoji, isShark = false } = {}) {
                if (!state.enabled || !state.layer || !pos) return;
                if (state.layer.children.length >= cfg.maxConcurrency && !isShark) return;

                const el = document.createElement('span');
                el.className = 'fish' + (isShark ? ' shark' : '');
                el.textContent = emoji || cfg.fishEmojis[0];
                el.style.left = pos.x + 'px';
                el.style.top  = pos.y + 'px';

                if (!isShark) {
                    el.style.fontSize = (1.6 + Math.random() * 1.0) + 'rem';
                    el.style.animationDuration = (1.5 + Math.random() * 0.8) + 's';
                    if (cfg.useArcProb > 0 && Math.random() < cfg.useArcProb) el.classList.add('arc');
                }

                el.addEventListener('animationend', () => el.remove());
                state.layer.appendChild(el);
                return el;
            }

            function spawnNormalByKey(key) {
                const pos = getRandomPos();
                const emoji = cfg.fishEmojis[(Math.random() * cfg.fishEmojis.length) | 0];
                spawnAt(pos, { emoji, isShark: false });
            }

            function spawnShark() {
                const pos = getRandomPos();
                spawnAt(pos, { emoji: cfg.sharkEmoji, isShark: true });
            }

            function onKeydown(e) {
                if (!state.enabled) return;
                if (e.repeat || e.metaKey || e.ctrlKey || e.altKey) return;

                const t = now();
                if (t - state.lastTs < cfg.minIntervalMs) return;
                state.lastTs = t;

                if (e.key === 'Enter') {
                    spawnShark();
                    return;
                }
                spawnNormalByKey(e.key);
            }

            const FishFX = {
                init,
                onKeydown,
                spawnShark,
                spawnAt,
                enable()  { state.enabled = true;  },
                disable() { state.enabled = false; },
                config(patch = {}) { Object.assign(cfg, patch); },
            };

            function autoInit() {
                init();
            }

            global.FishFX = FishFX;
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', autoInit, { once: true });
            } else {
                autoInit();
            }

        })(window);
        
        // Integrate fish effect with existing typing functionality
        document.addEventListener('keypress', function(e) {
            if (e.target.tagName === 'INPUT') return;
            
            const char = e.key;
            if (char.length !== 1) return;
            
            // Trigger fish effect for regular characters
            if (window.FishFX) {
                window.FishFX.onKeydown(e);
            }
        });
        
        // Trigger shark for Enter key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                if (window.FishFX) {
                    window.FishFX.onKeydown(e);
                }
            }
        });

        // --- Tutorial button & panel ---
        // Create tutorial HTML elements (button + panel)
        (function setupTutorial() {
            // Styles: inject minimal rules to keep everything in one file
            const style = document.createElement('style');
            style.textContent = `
            /* Tutorial button (bottom-right) */
            #tutorial-btn {
                position: fixed;
                right: 20px;
                bottom: 20px;
                width: 56px;
                height: 56px;
                border-radius: 12px;
                background: rgba(50,50,60,0.95);
                color: #fff;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2200;
                cursor: pointer;
                box-shadow: 0 8px 20px rgba(0,0,0,0.25);
                transition: transform 0.18s ease, background 0.18s ease;
                backdrop-filter: blur(6px);
            }
            #tutorial-btn:hover { transform: translateY(-3px) scale(1.03); }

            /* Tutorial panel */
            #tutorial-panel {
                position: fixed;
                right: 20px;
                bottom: 92px;
                width: 320px;
                max-width: calc(100% - 40px);
                background: rgba(255,255,255,0.98);
                color: #111;
                border-radius: 12px;
                box-shadow: 0 12px 30px rgba(0,0,0,0.22);
                padding: 16px;
                z-index: 2199;
                transform-origin: bottom right;
                transform: translateY(12px) scale(0.98);
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.18s ease, transform 0.18s ease;
                font-family: Arial, Helvetica, sans-serif;
                font-size: 14px;
            }
            #tutorial-panel.show {
                transform: translateY(0) scale(1);
                opacity: 1;
                pointer-events: auto;
            }

            #tutorial-panel h4 { margin: 0 0 8px 0; font-size: 16px; }
            #tutorial-panel p { margin: 6px 0; line-height: 1.4; color: #222; }
            #tutorial-panel .tutorial-actions { display:flex; gap:8px; margin-top:10px; }
            #tutorial-panel button { flex:1; padding:8px 10px; border-radius:8px; border:none; cursor:pointer; }
            #tutorial-panel .close-btn { background:#333; color:#fff; }
            #tutorial-panel .more-btn { background:transparent; border:1px solid #ddd; }
            `;
            document.head.appendChild(style);

            // Button
            const btn = document.createElement('button');
            btn.id = 'tutorial-btn';
            btn.title = 'Tutorial';
            btn.setAttribute('aria-label', 'Open tutorial');
            btn.innerHTML = `?`;
            document.body.appendChild(btn);

            // Panel
            const panel = document.createElement('div');
            panel.id = 'tutorial-panel';
            panel.setAttribute('role', 'dialog');
            panel.setAttribute('aria-hidden', 'true');
            panel.innerHTML = `
                <h4>How Calm Typing works</h4>
                <p>This site turns your typed characters into floating calm visuals and saves words you type to build a personal history.</p>
                <p>Basic actions:</p>
                <ul style="margin:6px 0 0 18px; padding:0; color:#333;">
                    <li>Type anywhere to create floating characters.</li>
                    <li>Space saves the current word (auto-correct applied).</li>
                    <li>Enter finalizes a sentence and triggers a gentle animation.</li>
                    <li>Use the top-right controls to change background, audio, fonts, and size.</li>
                </ul>
                <div class="tutorial-actions">
                    <button class="close-btn">Close</button>
                    <button class="more-btn">Read README</button>
                </div>
            `;
            document.body.appendChild(panel);

            // Toggle logic
            function openPanel() {
                panel.classList.add('show');
                panel.setAttribute('aria-hidden', 'false');
                btn.setAttribute('aria-pressed', 'true');
            }
            function closePanel() {
                panel.classList.remove('show');
                panel.setAttribute('aria-hidden', 'true');
                btn.setAttribute('aria-pressed', 'false');
            }

            btn.addEventListener('click', function(e) {
                e.stopPropagation();
                if (panel.classList.contains('show')) closePanel(); else openPanel();
            });

            // close when clicking outside
            document.addEventListener('click', function(e) {
                if (!panel.contains(e.target) && e.target !== btn) {
                    closePanel();
                }
            });

            // close on Escape
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') closePanel();
            });

            // Wire panel buttons
            panel.querySelector('.close-btn').addEventListener('click', closePanel);
            panel.querySelector('.more-btn').addEventListener('click', function() {
                // Try to open README if available; fallback to alert with short guide
                try {
                    window.open('README.md', '_blank');
                } catch (err) {
                    alert('See the project README for more details.');
                }
            });
        })();
        
        // Test function for debugging
        window.testBirds = function() {
            console.log('🧪 Testing bird features...');
            if (window.FishFX) {
                console.log('✅ FishFX is loaded');
                if (window.FishFX.testBackgroundDetection) {
                    window.FishFX.testBackgroundDetection();
                } else {
                    console.log('❌ testBackgroundDetection function not found');
                }
            } else {
                console.log('❌ FishFX not loaded');
            }
        };
    </script>
    
    <!-- Fish Animation Script -->
    <script src="fish.js"></script>
</body>
</html>
